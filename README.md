Author: Cuong Phan
### LeetCode Journal

| No. | Name    | Difficulty | Solution              |Notes|Time Complexity|Space Complexity|
| --- | ------- | ---------- | --------------------- |----|---|-|
| 1  | [Two Sum](https://leetcode.com/problems/two-sum/) | Easy       | [C#](./algorithms/cs/1_HashMap.cs) | C#: Use a hashmap to look up values at constant time.|C#: $O(n)$|C#: $O(n)$|
| 2  | [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) | Medium       | [C#](./algorithms/cs/2_LinkedLists.cs) | C#: Remember to check if the last addition requires a carry node|C#: $O(max(m, n))$|C#: $O(max(m, n))$|
| 3  | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | Medium       | [C#](./algorithms/cs/3_SlidingWindow.cs) | C#: Use a hashmap to to store the last visited index of a character.|C#: $O(n)$|C#: $O(min(m, n))$|
| 4  | [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/) | Hard      | [C#_Iterative](./algorithms/cs/4_Iterative.cs) | C# Iterative: Use two pointers to traverse the arrays until you encounter the medians.|C# Iterative: $O(m + n)$|C# Iterative: $O(1)$|
| 5  | [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) | Medium     | [C#](./algorithms/cs/5_CenterExpansion.cs) | C#: Use two pointers 'left' and 'right' of the substring with the ith element as its center and keep expanding by the sides as long as the string is palindromic. Remember to check the both odd and even lengths.|C#: $O(n^{2})$|C#: $O(1)$|
| 6  | [Zigzag Conversion](https://leetcode.com/problems/zigzag-conversion/) | Medium    | [C#](./algorithms/cs/6_Iterative.cs) | C#: Create an array of StringBuilder corresponding to the rows, iteratively append the characters into the StringBuilder array.|C#: $O(n)$|C#: $O(n)$|
| 7  | [Reverse Integer](https://leetcode.com/problems/reverse-integer/) | Medium    | [C#](./algorithms/cs/7_Iterative.cs) | C#: Check if underflows or overflows before adding the tail end digit to the result int iteratively using modulus.|C#: $O(log(n))$|C#: $O(1)$|
| 8  | [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/) | Medium    | [C#](./algorithms/cs/8_Iterative.cs) | C#: Skip leading whitespaces, check for sign, subtract ASCII '0' to get value, check if underflows or overflows. |C#: $O(n)$|C#: $O(1)$|
| 9  | [Palindrome Number](https://leetcode.com/problems/palindrome-number/) | Medium    | [C#](./algorithms/cs/9_MidReverse.cs) | C#: False if negative or divisible by 10 (excluding 0), reverse till middle, check if reversed = original (odd-length number) or reversed / 10 = original (even-length number). |C#: $O(log(n))$|C#: $O(1)$|
| 11  | [Container With Most Water](https://leetcode.com/problems/container-with-most-water/) | Medium    | [C#](./algorithms/cs/11_TwoPointers.cs)<br><br>[C++](./algorithms/cpp/11_TwoPointers.cpp) | C#: Use two pointers at the start and end of array, contract the container by the lower wall's side.<br><br>C++: Use two pointers at the start and end of array, contract the container by the lower wall's side. |C#: $O(n)$<br><br>C++: $O(n)$|C#: $O(1)$<br><br>C++: $O(1)$|
| 13  | [Roman to Integer](https://leetcode.com/problems/roman-to-integer/) | Easy    | [C++](./algorithms/cpp/13_Iterative.cpp) | C++: If the next numeral is larger then subtract the current one, else add it. |C++: $O(n)$|C++: $O(1)$|
| 15  | [3Sum](https://leetcode.com/problems/3sum/) | Medium    | [C++](./algorithms/cpp/15_TwoPointers.cpp) | C++: Sort the array, iterate through the array as "fixed value" then use two pointers on the subarray on the right to find the triplets. |C++: $O(n^2)$|C++: $O(1)$|
| 16  | [3Sum Closest](https://leetcode.com/problems/3sum-closest/) | Medium    | [C++](./algorithms/cpp/16_TwoPointers.cpp) | C++: Sort the array, iterate through the array as "fixed value" then use two pointers on the subarray on the right to find the triplet. |C++: $O(n^2)$|C++: $O(1)$|
| 17  | [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) | Medium    | [C++](./algorithms/cpp/17_Recursive.cpp) | C++: Use a recursive backtrack method. Base case if when the currentString is the same length as digits |C++: $O(3^N*4^M)$, N is the number of digits in the input string that map to 3 letters and M is the number of digits that map to 4 letters.|C++: $O(3^N*4^M)$|
| 20  | [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) | Easy    | [C++_StackMap](./algorithms/cpp/20_StackMap.cpp)<br><br>[C++_StackNoMap](./algorithms/cpp/20_StackNoMap.cpp) | C++_StackMap: Use a stack to keep track of the latest added opening parenthesis and a map to map opening parentheses to their closing counterparts.<br><br>C++_StackNoMap: Using conditions instead of a map may improve speed and lower space because there are only three parenthesis types in exchange for readability and scalability. |C++_StackMap: $O(N)$.<br><br>C++_StackNoMap: $O(N)$.|C++_StackMap $O(N)$<br><br>C++_StackNoMap: $O(N)$.|
| 21 | [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | Easy | [Python](./algorithms/py/21_Pointers.py) | Python: Splice together existing nodes from list1 and list2 by adjusting pointers. Tip: use a dummy node to simplify pointer set-up. |Python: $O(n + m)$|Python: $O(1)$|
| 22  | [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) | Medium    | [C++ DFS Recursive](./algorithms/cpp/22_DFSRecursive.cpp)<br><br>[C++ DFS Iterative](./algorithms/cpp/22_DFSIterative.cpp) | C++ DFS Recursive: Use recursion and 2 integers to keep track of how many opening and closing parentheses there are in the strings.<br><br>C++ DFS Iterative: Same as recursion but use a stack to track the string expression, opening and closing counts of parentheses. |[C++ DFS Recursive:](https://medium.com/data-structures-and-algorithms-dsa/generate-parentheses-1cee660a250d) $O(N*4^N)$<br><br>[C++ DFS Iterative:](https://medium.com/data-structures-and-algorithms-dsa/generate-parentheses-1cee660a250d) $O(N*4^N)$|[C++ DFS Recursive:](https://medium.com/data-structures-and-algorithms-dsa/generate-parentheses-1cee660a250d) $O(N)$ <br><br>[C++ DFS Iterative:](https://medium.com/data-structures-and-algorithms-dsa/generate-parentheses-1cee660a250d) $O(N)$|
| 27  | [Remove Element](https://leetcode.com/problems/remove-element/) | Easy    | [C++](./algorithms/cpp/27_TwoPointers.cpp) | C++: Use two pointers to find target values in the left and non-target values in the right to swap. |C++: $O(N)$.|C++: $O(1)$|
| 28  | [Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/) | Easy    | [C++](./algorithms/cpp/28_Iterative.cpp) | C++_Iterative: Use an iterative approach (you can use substr instead of another loop but it is less memory-efficient). |C++_Iterative: $O(N * M)$.|C++: $O(1)$|
| 35  | [Search Insert Position](https://leetcode.com/problems/search-insert-position/) | Easy    | [C++](./algorithms/cpp/35_BinarySearch.cpp) | C++: Binary search approach, remember to update the left and right pointers PAST the middle pointer. |C++: $O(log(n))$|C++: $O(1)$|
| 38  | [Count and Say](https://leetcode.com/problems/count-and-say/) | Medium    | [C++](./algorithms/cpp/38_Iterative.cpp) | C++: Iterative approach|C++: $O(n)$|C++: $O(2^n)$|
| 39  | [Combination Sum](https://leetcode.com/problems/combination-sum/) | Medium    | [C++](./algorithms/cpp/39_Backtrack.cpp) | C++: Recursive backtrack approach (remember to run j from i to avoid duplicate result as well as pass by reference to increase performance). |C++: $O(2^n)$|C++: $O(2^n)$|
| 41  | [First Missing Positive](https://leetcode.com/problems/first-missing-positive/) | Hard    | [C++](./algorithms/cpp/41_Swapping.cpp) | C++: Place each number in its corresponding index (1 in index 0, 2 in index 1, etc.), then iterate through the array to find the first missing positive number. |C++: $O(n)$|C++: $O(1)$|
| 55  | [Jump Game](https://leetcode.com/problems/jump-game/) | Medium    | [C++](./algorithms/cpp/55_Greedy.cpp) | C++: Use greedy algorithm, iterate through the vector, if current index is larger than max reach then return false else update max reach. |C++: $O(n)$|C++: $O(1)$|
| 58  | [Length of Last Word](https://leetcode.com/problems/length-of-last-word/) | Easy    | [C++](./algorithms/cpp/58_Iterative.cpp) | C++: Iterative approach, iterate from the back with 2 while loops (not nested). |C++: $O(n)$|C++: $O(1)$|
| 66  | [Plus One](https://leetcode.com/problems/plus-one/) | Easy    | [C++](./algorithms/cpp/66_Iterative.cpp) | C++: Don't try to add too many conditions in the loop. |C++: $O(n)$|C++: $O(1)$|
| 69  | [Sqrt(x)](https://leetcode.com/problems/sqrtx/) | Easy    | [Python](./algorithms/py/69_BinarySearch.py) | Python: Use binary search to find the largest integer such that `mid * mid <= x`. Return `upper` after the loop because it is the last valid value before `lower` surpasses it. |Python: $O(\log x)$|Python: $O(1)$|
| 75  | [Sort Colors](https://leetcode.com/problems/sort-colors/) | Medium    | [C++](./algorithms/cpp/75_ThreePointers.cpp) | C++: Use the Dutch National Flag (3-way partition algorithm). |C++: $O(n)$|C++: $O(1)$|
| 78  | [Subsets](https://leetcode.com/problems/subsets/) | Medium    | [Python DFS Iterative](./algorithms/py/78_DFSIterative.py) | Python DFS Iterative: Use the Dutch National Flag (3-way partition algorithm). |Python DFS Iterative: $O(2^n*n)$|C++: $O(2^n*n)$|
| 94  | [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/) | Easy    | [C++](./algorithms/cpp/94_Recursive.cpp) | C++: Use recursive depth-first traversal of the tree. |C++: $O(n)$|C++: $O(h)$ with h being the height of the tree.|
| 100  | [Same Tree](https://leetcode.com/problems/same-tree/) | Easy | [C++ DFS](./algorithms/cpp/100_DFSRecursive.cpp)<br><br>[Python DFS](./algorithms/py/100_DFSRecursive.py)<br><br>[Python BFS](./algorithms/py/100_BFSIterative.py) | C++ DFS: Use recursive depth-first traversal of the tree to see if each node pair is the same.<br><br>Python DFS: Use recursive depth-first traversal of the tree to see if each node pair is the same.<br><br>Python BFS: Use an iterative breadth-first traversal using a queue to compare each pair of nodes level by level.|C++: $O(n)$<br><br>Python DFS: $O(n)$<br><br>Python BFS: $O(n)$|C++: $O(h)$ with h being the height of the tree.<br><br>Python DFS: $O(h)$ with h being the height of the tree.<br><br>Python BFS: $O(w)$ with h being the max width of the tree.|
| 101  | [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/) | Easy | [C++ DFS](./algorithms/cpp/101_DFSRecursive.cpp)<br><br>[Python DFS](./algorithms/py/101_DFSRecursive.py)<br><br>[Python BFS](./algorithms/py/101_BFSIterative.py) | C++ DFS: Use recursive depth-first traversal of the tree to see if each node pair is the same.<br><br>Python DFS: Use recursive depth-first traversal of the tree to see if each node pair is the same.<br><br>Python BFS: Use an iterative breadth-first traversal using a queue to compare each pair of nodes level by level.|C++: $O(n)$<br><br>Python DFS: $O(n)$<br><br>Python BFS: $O(n)$|C++: $O(h)$ with h being the height of the tree.<br><br>Python DFS: $O(h)$ with h being the height of the tree.<br><br>Python BFS: $O(w)$ with w being the max width of the tree.|
| 102 | [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) | Medium | [Python](./algorithms/py/102_BFSIterative.py) | Python: Use BFS with a queue to traverse each level, grouping node values by depth. |Python: $O(n)$|Python: $O(w)$ with w being the maximum width of the tree.|
| 103 | [Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/) | Medium | [Python](./algorithms/py/103_BFSIterative.py) | Python: Use BFS with a queue to traverse each level. Append values left-to-right, then reverse on odd levels for zigzag pattern. |Python: $O(n)$|Python: $O(w)$ with w being the maximum width of the tree.|
| 104  | [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | Easy | [C++](./algorithms/cpp/104_DFSRecursive.cpp)<br><br>[Python BFS](./algorithms/py/104_BFSIterative.py) | C++: Use recursive depth-first traversal of the tree (check if the currentNode is nullptr before incrementing the count).<br><br>Python: Use BFS with a queue to traverse the tree level by level and count the number of levels. |C++: $O(n)$<br><br>Python BFS: $O(n)$|C++: $O(h)$ with h being the height of the tree.<br><br>Python BFS: $O(w)$ with w being the max width of the tree.|
| 107 | [Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/) | Medium | [Python](./algorithms/py/107_BFSIterative.py) | Python: Use BFS with a queue to traverse the tree level by level. Prepend each level to a deque using `appendleft()` to build the result from bottom to top efficiently. |Python: $O(n)$|Python: $O(w)$ with w being the maximum width of the tree.|
| 111  | [Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/) | Easy    | [C++ DFS](./algorithms/cpp/111_DFSRecursive.cpp)<br><br>[Python BFS](./algorithms/py/111_BFSIterative.py) | C++ DFS: Use recursive depth-first traversal of the tree.<br><br>Python BFS: Use BFS with a queue to traverse level by level. Return the depth when the first leaf node is found. |C++ DFS: $O(n)$<br><br>ython BFS: $O(n)$|C++ DFS: $O(h) with h being the height of the tree.$<br><br>Python BFS: $O(w)$ with w being the maximum width of the tree.|
| 112  | [Path Sum](https://leetcode.com/problems/path-sum/) | Easy    | [C++](./algorithms/cpp/112_Recursive.cpp)<br><br>[Python DFS](./algorithms/py/112_DFSIterative.py) | C++: Use recursive depth-first traversal of the tree.<br><br>Python DFS: Use iterative DFS with a stack. At each node, subtract its value from the remaining target sum. If a leaf node is reached and the remaining sum is zero, return True. |C++: $O(n)$<br><br>Python: $O(n)$|C++: $O(h)$ with h being the height of the tree.<br><br>Python: $O(h)$ with h being the height of the tree.|
| 118  | [Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/) | Easy    | [C++](./algorithms/cpp/118_Combinatorial.cpp) | C++: Initialize each row with values of 1, adjust the middle values with combinatorial formula. |C++: $O(n^2)$|C++: $O(n^2)$|
| 119  | [Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/) | Easy    | [C++_TwoRows](./algorithms/cpp/119_TwoRows.cpp)<br><br>[C++_OneRow](./algorithms/cpp/119_OneRow.cpp) | C++_TwoRows: Make base rows - vector<int> prevRow(1, 1) and use two vectors to store the current row and the previous row for calculation. <br><br>C++_OneRow: Use a single row with size rowIndex + 1, calculate the middle values backwards (row[j] += row[j - 1]).|C++_TwoRows: $O(n^2)$<br><br>C++_OneRow: $O(n^2)|C++_TwoRows: $O(n)$<br><br>C++_OneRow: $O(n)$|
| 121  | [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) | Easy    | [C++](./algorithms/cpp/121_Iterative.cpp) | C++: Update minBuy and maxProfit separately. |C++: $O(n)$|C++: $O(1)$|
| 122  | [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) | Medium    | [C++](./algorithms/cpp/122_Iterative.cpp) | C++: If price is lower, update minBuy if not sell constantly. |C++: $O(n)$|C++: $O(1)$|
| 125  | [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) | Easy    | [C++](./algorithms/cpp/125_TwoPointers.cpp) | C++: Two pointers. |C++: $O(n)$|C++: $O(1)$|
| 136  | [Single Number](https://leetcode.com/problems/single-number/) | Easy    | [C++](./algorithms/cpp/136_XOR.cpp) | C++: XOR each element of the array (if an element appears twice, XOR would be 0 which means XOR product of the entire array is the element that only appears once) and order and position do not matter in XOR. |C++: $O(n)$|C++: $O(1)$|
| 141  | [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) | Easy    | [C++](./algorithms/cpp/141_FloydsCycleDetection.cpp) | C++: Use Floyd's Cycle Detection, have 2 pointers called slow and fast, slow iterate through each node, fast skips a node. If the fast pointer exits the list, no cycle if the fast and slow pointers meet, there is a cycle. |C++: $O(n)$|C++: $O(1)$|
| 144  | [Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/) | Easy    | [C++](./algorithms/cpp/144_Recursive.cpp) | C++: Use recursive approach. |C++: $O(n)$|C++: $O(h)$|
| 145  | [Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/) | Easy    | [C++](./algorithms/cpp/145_Recursive.cpp) | C++: Use recursive approach. |C++: $O(n)$|C++: $O(h)$|
| 167  | [Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) | Medium    | [C++](./algorithms/cpp/167_TwoPointers.cpp) | C++: Use two pointers and increment or decrement them so that the sum creep towards the target. |C++: $O(n)$|C++: $O(1)$|
| 169  | [Majority Element](https://leetcode.com/problems/majority-element/) | Medium    | [C++_Map](./algorithms/cpp/169_Map.cpp)<br><br>[C++_Sorting](./algorithms/cpp/169_Sorting.cpp) | C++_Map: Use a frequency map to keep track of the elements.<br><br>C++_Sorting: Sort the array, the majority element is guaranteed to be in the middle index of the array. |C++_Map: $O(n)$<br><br>C++_Sorting: $O(log(n))$|C++_Map: $O(n)$<br><br>C++_Sorting: $O(1)$|
| 202  | [Happy Number](https://leetcode.com/problems/happy-number/) | Easy    | [C++_UnorderedSet](./algorithms/cpp/202_UnorderedSet.cpp) | C++_UnorderedSet: Use unordered set to keep track of what sum has been seen to detect cycle.|C++_UnorderedSet: $O(log(n))$ |C++_UnorderedSet: $O(log(n))$|
| 217  | [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) | Easy    | [C++_Set](./algorithms/cpp/217_Set.cpp)<br><br>[C++_Sorting](./algorithms/cpp/217_Sorting.cpp) | C++_Set: Use a set to keep track of which number has been tracked.<br><br>Sort the nums array, iterate through the array and check if the current value is the same as the next value.|C++_Set: $O(n)$<br><br> C++_Sorting: $O(n*log(n))$|C++_Set: $O(n)$<br><br>C++_Sorting: $O(1)$|
| 219  | [Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/) | Easy    | [C++_Map](./algorithms/cpp/219_Map.cpp) | C++: Use a map to store the most recent index of the current value (besides the current index). Check if the condition is met, if not update the most recent index to the current index.|C++: $O(n)$ |C++: $O(n)$|
| 222  | [Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/) | Easy    | [C++](./algorithms/cpp/222_Recursive.cpp) | C++: Use a recursive approach. |C++: $O(n)$ |C++: $O(h)$ |
| 225  | [Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/) | Easy    | [C++](./algorithms/cpp/225_OneQueue.cpp) | C++: Use one queue. |C++: N/A |C++: N/A |
| 228  | [Summary Ranges](https://leetcode.com/problems/summary-ranges/) | Easy    | [C++](./algorithms/cpp/228_Iterative.cpp) | C++: Use iterative approach. |C++: $O(n)$ |C++: $O(1)$ |
| 232  | [Implement Queue using Stacks](https://leetcode.com/problems/product-of-array-except-self/) | Easy    | [C++](./algorithms/cpp/232_TwoStacks.cpp) | C++: Use two stacks. |C++: N/A |C++: N/A |
| 238  | [Product of Array Except Self](https://leetcode.com/problems/implement-queue-using-stacks/) | Medium    | [Python](./algorithms/py/238_TwoPasses.py) | Python: Two-pass prefix & suffix product approach without division. |Python: $O(n)$ | Python: $O(1)$ |
| 242  | [Valid Anagram](https://leetcode.com/problems/valid-anagram/) | Easy    | [C++_Sorting](./algorithms/cpp/242_Sorting.cpp)<br><br>[C++_Map](./algorithms/cpp/242_Map.cpp)<br><br>[C++_MapArray](./algorithms/cpp/242_MapArray.cpp) | C++_Sorting: Sort the two strings then compare.<br><br>C++_Map: Use a map to store the frequencies of the characters, increment if appears in string s, decrement if appears in string t. Return true if all characters have frequency of 0.<br><br>C++_MapArray: Same logic but we can use an array with 26 elements for 26 characters in the alphabet (would not work for the follow-up question). |C++_Sorting: $O(nlog(n))$<br><br>C++_Map: $O(n)$<br><br>C++_MapArray: $O(n)$ |C++_Sorting: $O(1)$<br><br>C++_Map:$O(n)$<br><br>C++_Map:$O(1)  |
| 263  | [Ugly Number](https://leetcode.com/problems/ugly-number/) | Easy    | [C++](./algorithms/cpp/263_Recursive.cpp) | C++: Use a recursive approach.|C++: N/A |C++: N/A|
| 268  | [Missing Number](https://leetcode.com/problems/missing-number/) | Easy    | [C++_Vector](./algorithms/cpp/268_Vector.cpp)<br><br>[C++_Maths](./algorithms/cpp/268_Maths.cpp) | C++_Vector: Use a boolean vector to keep track of which number is present.<br><br>C++_Maths: Use the sum formula to get the sum for integers from 0 to n: $(n * (n + 1)) / 2$ then subtract the sum of nums elements from it to get the result.  |C++_Vector: $O(n)$<br><br>C++_Maths: $O(n)$ |C++_Vector: $O(n)$<br><br> C++ Maths: $O(1)$|
| 278  | [First Bad Version](https://leetcode.com/problems/first-bad-version/) | Easy    | [C++_TwoPointers](./algorithms/cpp/278_TwoPointers.cpp) | C++: Use two pointers approach.|C++: $O(log(n))$ |C++: $O(1)$|
| 283  | [Move Zeroes](https://leetcode.com/problems/move-zeroes/) | Easy | [Python](./algorithms/py/283_TwoPointers.py) | Python: Use two pointers to shift non-zero elements forward and fill the rest with zeroes. |Python: $O(n)$ |Python: $O(1)$ |
| 290  | [Word Pattern](https://leetcode.com/problems/word-pattern/) | Easy    | [C++_Maps](./algorithms/cpp/290_Maps.cpp) | C++_Maps: Use 2 maps strToPat and patToStr to check for bijection. |C++_Maps: $O(n)$ |C++_Maps: $O(n)$|
| 338  | [Counting Bits](https://leetcode.com/problems/counting-bits/) | Easy    | [C++](./algorithms/cpp/338_Tabulation.cpp) | C++: Bottom-up DP approach. |C++: $O(n)$|C++: $O(1)$|
| 344  | [Reverse String](https://leetcode.com/problems/reverse-string/) | Easy    | [Python](./algorithms/py/344_TwoPointers.py) | Python: Use two pointers (`left` and `right`) to swap characters in-place until the middle is reached. |Python: $O(n)$|Python: $O(1)$|
| 345  | [Reverse Vowels of a String](https://leetcode.com/problems/reverse-vowels-of-a-string/) | Easy    | [C++](./algorithms/cpp/345_TwoPointers.cpp) | C++: Two pointers approach. |C++: $O(n)$|C++: $O(1)$|
| 345  | [Reverse Vowels of a String](https://leetcode.com/problems/reverse-vowels-of-a-string/) | Easy    | [C++](./algorithms/cpp/345_TwoPointers.cpp) | C++: Two pointers approach. |C++: $O(n)$|C++: $O(1)$|
| 349  | [Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/) | Easy | [C++](./algorithms/cpp/349_Set.cpp)<br><br>[Python](./algorithms/py/349_Set.py) | C++: Use `unordered_set` to store unique elements from `nums1`, then check membership for each element in `nums2`, inserting common ones into a result set.<br><br>Python: Use `set` to store `nums1`, then iterate through `nums2` and collect elements that exist in `nums1`. Return the result as a list. | C++: $O(n + m)$<br><br>Python: $O(n + m)$ | C++: $O(n + m)$<br><br>Python: $O(n + m)$ |
| 367 | [Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square/) | Easy | [Python](./algorithms/py/367_BinarySearch.py) | Python: Use binary search to find if an integer square equals the target number. | Python: $O(\log n)$ | Python: $O(1)$ |
| 374  | [Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/) | Easy    | [C++](./algorithms/cpp/374_BinarySearch.cpp) | C++: Binary search approach. |C++: $O(log(n))$|C++: $O(1)$|
| 383  | [Ransom Note](https://leetcode.com/problems/ransom-note/) | Easy    | [C++](./algorithms/cpp/383_UnorderedMap.cpp) | C++: Build a map from the magazine then iterate and decrement map value by character's appearance in the ransom note. |C++: $O(m + n)$|C++: $O(m)$|
| 387  | [First Unique Character in a String](https://leetcode.com/problems/first-unique-character-in-a-string/) | Easy | [Python](./algorithms/py/387_TwoPasses.py) | Python: Use a fixed-size array of 26 elements to count character occurrences, then scan the string to find the first unique character. This avoids the overhead of using a hash map. | Python: $O(n)$ | Python: $O(1)$ |
| 389  | [Find the Difference](https://leetcode.com/problems/find-the-difference/) | Easy    | [C++_Sorting](./algorithms/cpp/389_Sorting.cpp)<br><br>[C++_Map](./algorithms/cpp/389_Map.cpp) | C++_Sorting: Sort both strings then compare to find the difference iteratively.<br><br>C++_Map: Build a frequency map of the string s then retract the occurences of characters in string t, whichever character has a negative frequency is the difference. |C++_Sorting: $O(n*log(n))$<br><br>C++_Map: $O(n)$|C++_Sorting: $O(m)$<br><br>C++_Map: $O(1)$ because at most, it'll store 26 characters|
| 392  | [Is Subsequence](https://leetcode.com/problems/is-subsequence/) | Easy    | [C++](./algorithms/cpp/392_Iterative.cpp) | C++: Iterative approach. |C++: $O(n)$|C++: $O(1)$|
| 404  | [Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves/) | Easy    | [C++](./algorithms/cpp/404_Recursive.cpp) | C++: Use a recursive DFS approach, include a boolean to keep track of whether the last connection is a left or right connection. |C++: $O(n)$|C++: $O(h)$|
| 412  | [Fizz Buzz](https://leetcode.com/problems/fizz-buzz/) | Easy    | [C++](./algorithms/cpp/412_Iterative.cpp) | C++: Use vector to handle divisors and corresponding strings to make the code more flexible. |C++: $O(n)$|C++: $O(h)$|
| 443  | [String Compression](https://leetcode.com/problems/string-compression/) | Medium    | [Python](./algorithms/py/443_TwoPointers.py) | Python: Use two pointers to read and write characters in-place. Count repeats and write character + count if >1. |Python: $O(n)$|Python: $O(1)$|
| 513  | [Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/) | Easy    | [C++](./algorithms/cpp/513_Recursive.cpp) | C++: Use a recursive DFS approach, to ensure the left-most value among the last row is encountered first. |C++: $O(n)$|C++: $O(h)$|
| 605  | [Can Place Flowers](https://leetcode.com/problems/can-place-flowers/) | Easy    | [C++](./algorithms/cpp/605_Iterative.cpp) | C++: Iterative approach, can also skip the next 1 or 2 elements if the current or the next element is occupied. |C++: $O(n)$|C++: $O(1)$|
| 637  | [Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/) | Easy    | [C++](./algorithms/cpp/637_Recursive.cpp) | C++: Recursive approach, use 2 vectors to store the sum at each level and the number of nodes at each level. |C++: $O(n)$|C++: $O(n)$|
| 643  | [Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/) | Easy    | [C++](./algorithms/cpp/643_Iterative.cpp) | C++: Iterative approach, just look for the maximum sum then do the averaging later, remember to do typecasting at the end to get the right result. |C++: $O(n)$|C++: $O(1)$|
| 649  | [Dota2 Senate](https://leetcode.com/problems/dota2-senate/) | Easy    | [C++](./algorithms/cpp/649_TwoQueues.cpp) | C++: Use the two-queue approach. Initialize two queues for the two factions with index as value. Compare the fronts of the queue (lower index survives), push the surviving senator to the end of the queue with its index + size of the input then pop both fronts of the queues till one queue is empty. The non-empty queue at the end wins.  |C++: $O(n)$|C++: $O(n)$|
| 700  | [Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/) | Easy    | [C++](./algorithms/cpp/700_Recursive.cpp) | C++: Recursive approach. |C++: $O(log(n))$|C++: $O(1)$|
| 704  | [Binary Search](https://leetcode.com/problems/binary-search/) | Easy    | [C++](./algorithms/cpp/704_TwoPointers.cpp) | C++: Two Pointers Approach. |C++: $O(log(n))$|C++: $O(1)$|
| 724  | [Find Pivot Index](https://leetcode.com/problems/find-pivot-index/) | Easy    | [C++](./algorithms/cpp/724_Iterative.cpp) | C++: Iterative approach. |C++: $O(n)$|C++: $O(1)$|
| 746  | [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/) | Easy    | [C++](./algorithms/cpp/746_Tabulation.cpp) | C++: Bottom-up DP approach. |C++: $O(n)$|C++: $O(1)$|
| 771 | [Jewels and Stones](https://leetcode.com/problems/jewels-and-stones/) | Easy    | [C++](./algorithms/cpp/771_Set.cpp) | C++: Use a set to lookup which stone is a jewel better. |C++: $O(n + m)$ with n being the number of characters and m being the number of characters in stones|C++: $O(n)$ with n being the number of characters in jewels|
| 804 | [Unique Morse Code Words](https://leetcode.com/problems/unique-morse-code-words/) | Easy    | [C++](./algorithms/cpp/804_ArraySet.cpp) | C++: Use an array to encode the characters then use a set to ensure the transformations are unique. The size of the set at the end is the number of unique transformations. |C++: $O(n * m)$|C++: $O(n * m)$|
| 872 | [Leaf-Similar Trees](https://leetcode.com/problems/leaf-similar-trees/) | Easy    | [C++](./algorithms/cpp/872_Recursive.cpp) | C++: Recursively get all the leaf values into 2 vectors, compare the vectors at the end. |C++: $O(n)$|C++: $O(n)$|
| 938  | [Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/) | Easy    | [C++](./algorithms/cpp/938_Recursive.cpp) | C++: Use a recursive DFS approach. |C++: $O(n)$|C++: $O(h)$|
| 1052  | [Grumpy Bookstore Owner](https://leetcode.com/problems/grumpy-bookstore-owner/) | Medium    | [C++](./algorithms/cpp/1052_SlidingWindow.cpp) | C++: Use sliding window, in the loop use 3 checks (1 for left, 1 for right and 1 for max update). |C++: $O(n)$|C++: $O(1)$|
| 1108  | [Defanging an IP Address](https://leetcode.com/problems/defanging-an-ip-address/) | Easy    | [C++](./algorithms/cpp/1108_StraightForward.cpp) | C++: Use a straightforward approach. |C++: $O(n)$|C++: $O(n)$|
| 1137  | [N-th Tribonacci Number](https://leetcode.com/problems/n-th-tribonacci-number/) | Easy    | [C++](./algorithms/cpp/1137_Iterative.cpp) | C++: Use an iterative approach (similar to DP but storing only 3 of the previously calculated values). |C++: $O(n)$|C++: $O(1)$|
| 1207 | [Unique Number of Occurrences](https://leetcode.com/problems/unique-number-of-occurrences/) | Easy    | [C++](./algorithms/cpp/1207_MapSet.cpp) | C++: Convert the array to a frequency map then iterate through the map and check for duplicate values using a set. |C++: $O(n)$|C++: $O(n)$|
| 1302  | [Deepest Leaves Sum](https://leetcode.com/problems/deepest-leaves-sum/) | Easy    | [C++](./algorithms/cpp/1302_Recursive.cpp) | C++: Use a recursive DFS approach, whenever a leaf is reached, if its depth is greater than the max depth calculated so far, the sum should be restarted, if it is equal to the max depth, continuing summing, if not skip it. |C++: $O(n)$|C++: $O(h)$|
| 1370| [Increasing Decreasing String](https://leetcode.com/problems/increasing-decreasing-string/) | Easy    | [C++](./algorithms/cpp/1370_Array.cpp) | C++: Build a frequency map with an array (we can achieve O(1) lookup because we only deal with the 26 English letters). While the result string is shorter than the input string, we alternately loop through the frequency map (incrementing then decrementing the index) and add in characters to the result string. |C++: $O(n)$|C++: $O(1)$|
| 1431  | [Kids With the Greatest Number of Candies](https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/) | Easy    | [C++](./algorithms/cpp/1431_Iterative.cpp) | C++: Find max then build boolean vector. |C++: $O(n)$|C++: $O(1)$|
| 1456  | [Maximum Number of Vowels in a Substring of Given Length](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/) | Medium    | [C++_Set](./algorithms/cpp/1456_SetSlidingWindow.cpp)<br><br>[C++_Conditionals](./algorithms/cpp/1456_ConditionalSlidingWindow.cpp) | C++_Set: Use 'find' or 'count' on a vowel set then use a sliding window to decrement or increment curVowels count for the subarray window.<br><br>C++_Conditionals: Use the same logic but check if the character is a vowel by conditions, it may be less readable and scalable but since the number of vowels are only 5, it often improves performance. |C++_Set: $O(n)$<br><br>C++_Conditionals: $O(n)$|C++_Set: $O(1)$<br><br>$O(1)$|
| 1470 | [Shuffle the Array](https://leetcode.com/problems/shuffle-the-array/) | Easy    | [C++](./algorithms/cpp/1470_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n)$|C++: $O(n)$|
| 1512  | [Number of Good Pairs](https://leetcode.com/problems/number-of-good-pairs/) | Easy    | [C++_MapSingleLoop](./algorithms/cpp/1512_MapSingleLoop.cpp)<br><br>[C++_MapTwoLoops](./algorithms/cpp/1512_MapTwoLoops.cpp) | C++_MapSingleLoop: Build a frequency map and increase the counter of good pairs at the same time (the number of good pairs is the sum of incrementing series of natural numbers to n - 1 with n being the number of occurrences of a number)<br><br>C++_MapTwoLoops: Use the same logic but calculate the the number of good pairs using the sum formula: $S_n = (n / 2)(n + 1)$ |C++_MapSingleLoop: $O(n)$<br><br>C++_MapTwoLoops: $O(n)$|C++_MapSingleLoop: $O(k)$ with k being the number of distinct elements<br><br>C++_MapTwoLoops:$O(k)$ with k being the number of distinct elements|
| 1598| [Crawler Log Folder](https://leetcode.com/problems/crawler-log-folder/) | Easy    | [C++](./algorithms/cpp/1598_Iterative.cpp) | C++: The problem is basically the same as calculating the depth of the folder tree at the end. |C++: $O(n)$|C++: $O(1)$|
| 1614 | [Richest Customer Wealth](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/) | Easy    | [C++](./algorithms/cpp/1614_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n)$|C++: $O(1)$|
| 1672 | [Richest Customer Wealth](https://leetcode.com/problems/richest-customer-wealth/) | Easy    | [C++](./algorithms/cpp/1672_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n^2)$|C++: $O(1)$|
| 1684 | [Count of Number of Consistent Strings](https://leetcode.com/problems/count-the-number-of-consistent-strings/) | Easy    | [C++](./algorithms/cpp/1684_Array.cpp) | C++: Build a boolean array to keep track of which of the 26 English letters are allowed. Loop through the words and if there exists a disallowed letter, decrement the counter. |C++: $O(n^2)$|C++: $O(1)$|
| 1732  | [Find the Highest Altitude](https://leetcode.com/problems/find-the-highest-altitude/) | Easy    | [C++](./algorithms/cpp/1732_Iterative.cpp) | C++: Iterative approach. |C++: $O(n)$|C++: $O(1)$|
| 1742  | [Maximum Number of Balls in a Box](https://leetcode.com/problems/maximum-number-of-balls-in-a-box/) | Easy    | [C++](./algorithms/cpp/1742_Array.cpp) | C++: Our first intuition is to use a hash but it is not necessary, we can just use an array of 46 integers to keep track of the frequency (because the highLimit is constrained to be not larger than 10^5). |C++: $O(n)$|C++: $O(1)$|
| 1748  | [Sum of Unique Elements](https://leetcode.com/problems/sum-of-unique-elements/) | Easy    | [C++](./algorithms/cpp/1748_Map.cpp) | C++: Build a frequency map then sum the numbers that appear once. |C++: $O(n)$|C++: $O(n)$|
| 1768  | [Merge Strings Alternately](https://leetcode.com/problems/merge-strings-alternately/) | Easy    | [C++](./algorithms/cpp/1768_OnePointer.cpp) | C++: Use only one pointer to keep track of the indices. |C++: $O(n)$|C++: $O(1)$|
| 1832 | [Check if the Sentence Is Pangram](https://leetcode.com/problems/check-if-the-sentence-is-pangram/) | Easy    | [C++](./algorithms/cpp/1832_Array.cpp) | C++: Use a boolean array corresponding to the 26 English letters, if the currentElement has not been seen, increase the seen number counter and turn the hasSeen boolean value to the according letter to true. If the counter is equal to 26, return true. |C++: $O(n)$|C++: $O(1)$|
| 1920 | [Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/) | Easy    | [C++](./algorithms/cpp/1920_Iterative.cpp) | C++: Iterative approach. |C++: $O(n)$|C++: $O(n)$|
| 1929  | [Concatenation of Array](https://leetcode.com/problems/concatenation-of-arry/) | Easy    | [C++](./algorithms/cpp/1929_Iterative.cpp) | C++: Iterative approach with the modulo operator. |C++: $O(n)$|C++: $O(n)$|
| 2037  | [Minimum Number of Moves to Seat Everyone](https://leetcode.com/problems/mininum-number-of-moves-to-seat-everyone/) | Easy    | [C++](./algorithms/cpp/2037_Sorting.cpp) | C++: Sort the arrays, then calculate the difference between the paired elements. |C++: $O(nlog(n))$|C++: $O(log(n))$|
| 2108 | [Find First Palindromic String in the Array](https://leetcode.com/problems/find-first-palindromic-string-in-the-array/) | Easy    | [C++](./algorithms/cpp/2108_TwoPointers.cpp) | C++: Iterate through the words vector, use two pointers left and right to check if the current word is palindromic |C++: $O(n * m)$|C++: $O(n)$|
| 2149 | [Rearrange Array Elements by Sign](https://leetcode.com/problems/rearrange-array-elements-by-sign/) | Medium    | [C++](./algorithms/cpp/2149_TwoPointers.cpp) | C++: Use two pointers neg and pos to keep track of which position to add the current value from the nums vector to the result veector.|C++: $O(n)$|C++: $O(n)$|
| 2215 | [Find the Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/) | Easy    | [C++](./algorithms/cpp/2215_Set.cpp) | C++: Use sets to avoid duplicates and constant lookup time. |C++: $O(n)$|C++: $O(n)$|
| 2325 | [Decode the Message](https://leetcode.com/problems/decode-the-message/) | Easy    | [C++_Map](./algorithms/cpp/2325_Map.cpp) | C++_Map: Build a substitution table with a map then decode the message string. |C++_Map: $O(m)$ with m being the size of message |C++_Map: $O(1)$ because at most we'll store 26 elements in a map. |
| 2351 | [First Letter to Appear Twice](https://leetcode.com/problems/first-letter-to-appear-twice/) | Easy    | [C++_Set](./algorithms/cpp/2351_Set.cpp) | C++: Use a set to keep track of which letter has been seen. |C++: $O(n)$ |C++: $O(1)$ because at most we'll store 26 elements in the set. |
| 2384 | [Largest Palindromic Number](https://leetcode.com/problems/largest-palindromic-number/) | Medium    | [C++_Array](./algorithms/cpp/2384_Array.cpp) | C++: Build a frequency map with an array, build a decreasing left string (remember to skip leading zeroes), build a middle string if there is a left-over digit, build a right string (reversed left string) and append all three small strings to return. |C++: $O(n)$ |C++: $O(1)$ because at most we'll store 26 elements in the set. |
| 2413 | [Smallest Even Multiple](https://leetcode.com/problems/smallest-even-multiple/) | Easy    | [C++](./algorithms/cpp/2413_StraightForward.cpp) | C++: Straightforward approach. |C++: $O(1)$ |C++: $O(1)$ |
| 2460 | [Apply Operations to an Array](https://leetcode.com/problems/apply-operations-to-an-array/) | Easy    | [Python](./algorithms/py/2460_TwoPointers.py) | Python: In-place two-pass approach (merge, then shift non-zeroes). | Python: $O(n)$ | Python: $O(1)$ |
| 2469 | [Convert the Temperature](https://leetcode.com/problems/convert-the-temperature/) | Easy    | [C++](./algorithms/cpp/2469_StraightForward.cpp) | C++: Straightforward approach. |C++: $O(1)$ |C++: $O(1)$ |
| 2716 | [Minimize String Length](https://leetcode.com/problems/first-letter-to-appear-twice/) | Easy    | [C++](./algorithms/cpp/2716_Array.cpp) | C++: This problem can be restated as counting the number of distinct elements. We can use a boolean arrays of 26 elements to keep track of which character has been seen. Return the number of 'true' in the array. |C++: $O(n)$ |C++: $O(1)$ |
| 2769 | [Find the Maximum Achievable Number](https://leetcode.com/problems/find-the-maximum-achievable-number/) | Easy    | [C++](./algorithms/cpp/2769_StraightForward.cpp) | C++: One liner. |C++: $O(1)$ |C++: $O(1)$ |
| 2798 | [Number of Employees Who Met the Target](https://leetcode.com/problems/number-of-employees-who-met-the-target/) | Easy    | [C++](./algorithms/cpp/2798_StraightForward.cpp) | C++: Straightforward approach. |C++: $O(1)$ |C++: $O(1)$ |
| 2842| [Count Pairs Whose Sum is Less than Target](https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/) | Easy    | [C++](./algorithms/cpp/2842_Iterative.cpp) | C++: Iterative approach. |C++: $O(n^2)$ |C++: $O(1)$ |
| 2903| [Find Indices With Index and Value Difference I](https://leetcode.com/problems/find-indices-with-index-and-value-difference-i/) | Easy    | [C++](./algorithms/cpp/2903_Iterative.cpp) | C++: Iterative approach. |C++: $O(n^2)$ |C++: $O(1)$ |
| 2942 | [Find Words Containing Character](https://leetcode.com/problems/find-words-containing-character/) | Easy    | [C++](./algorithms/cpp/2942_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n * m)$ with n being the number of words and m being the number of characters a word has. |C++: $O(n)$|
| 3110 | [Score of a String](https://leetcode.com/problems/score-of-a-string/) | Easy    | [C++](./algorithms/cpp/3110_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n)$|C++: $O(1)$|
| 3121 | [Count the Number of Special Characters II](https://leetcode.com/problems/count-the-number-of-special-characters-ii/) | Medium    | [C++](./algorithms/cpp/3121_Array.cpp) | C++: Use two arrays to keep track of whether the character is seen. Iterate through the input word, if the current character is lowercase then change the lowercase values to the opposite of the uppercase values, if the current character is uppercase then switch the bool value to true. |C++: $O(n)$|C++: $O(1)$|
| 3146 | [Permutation Difference between Two Strings](https://leetcode.com/problems/permutation-difference-between-two-strings/) | Easy    | [C++](./algorithms/cpp/3146_Set.cpp) | C++: Use a single set to store the index of characters in string s then directly calculate the difference while looping through string t. |C++: $O(n)$|C++: $O(n)$|
| 3151 | [Special Array I](https://leetcode.com/problems/special-array/) | Easy    | [Python](./algorithms/py/3151_Bitwise.py) | Python: Use bitwise AND 1 instead of modulo 2 for faster odd-even check, prev and cur variables to avoid redundant odd-even checkings. |Python: $O(n)$|Python: $O(1)$|
| 3162 | [Find the Number of Good Pairs I](https://leetcode.com/problems/find-the-number-of-good-pairs-i/) | Easy    | [C++](./algorithms/cpp/3162_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n^2)$|C++: $O(1)$|
| 3190 | [Find Minimum Operations to Make All Elements Divisible by Three](https://leetcode.com/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/) | Easy    | [C++](./algorithms/cpp/3190_Iterative.cpp) | C++: The problem is exactly the same as finding the number of elements that are not divisible by three (because we can make non-divisible by three into divisible by three in one operation).|C++: $O(n)$|C++: $O(1)$|