Author: Cuong Phan
### LeetCode Journal
| No. | Name    | Difficulty | Solution              |Notes|Time Complexity|Space Complexity|
| --- | ------- | ---------- | --------------------- |----|---|-|
| 1  | [Two Sum](https://leetcode.com/problems/two-sum/) | Easy       | <b>Hashing:</b><br>[C#](./algorithms/cs/1_Hashing.cs) | Hashing:<br>Use a hashmap to look up values at constant time.|Hashing:<br>$O(n)$|Hashing:<br>$O(n)$|
| 2  | [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) | Medium       | <b>Linked List:</b><br>[C#](./algorithms/cs/2_LinkedList.cs) | Linked List:<br> Remember to check if the last addition requires a carry node|Linked List:<br> $O(max(m, n))$|Linked List:<br> $O(max(m, n))$|
| 3  | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | Medium       | <b>Sliding Window:</b><br>[C#](./algorithms/cs/3_SlidingWindow.cs) | Sliding Window:<br> Use a hashmap to store the last visited index of a character.|Sliding Window:<br> $O(n)$|Sliding Window:<br> $O(min(m, n))$|
| 4  | [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/) | Hard      | <b>Two Pointers:</b><br>[C#](./algorithms/cs/4_TwoPointers.cs) | Two Pointers:<br> Use two pointers to simulate merging the arrays. Stop once the middle element(s) are reached.|Two Pointers:<br> $O(m + n)$|Two Pointers:<br> $O(1)$|
| 5  | [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) | Medium     | <b>Center Expansion:</b><br>[C#](./algorithms/cs/5_CenterExpansion.cs) | Center Expansion:<br> Use two pointers `left` and `right` of the substring with the ith element as its center and keep expanding by the sides as long as the string is palindromic. Remember to check the both odd and even lengths.|Center Expansion:<br> $O(n^{2})$|Center Expansion:<br> $O(1)$|
| 6  | [Zigzag Conversion](https://leetcode.com/problems/zigzag-conversion/) | Medium    | <b>Simulation:</b><br>[C#](./algorithms/cs/6_Simulation.cs) | Simulation:<br> Track the current row while traversing the string. Append characters to rows based on current direction (down or up). Reverse direction at the top or bottom row. |Simulation:<br> $O(n)$|Simulation:<br> $O(n)$|
| 7  | [Reverse Integer](https://leetcode.com/problems/reverse-integer/) | Medium    | <b>Math:</b><br>[C#](./algorithms/cs/7_Math.cs) | Math:<br> Check for underflow/overflow before adding the tail end digit to the result using modulus.| Math:<br> $O(\log n)$| Math:<br> $O(1)$|
| 8  | [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/) | Medium    | <b>Math:</b><br>[C#](./algorithms/cs/8_Math.cs) | Math:<br> Skip leading whitespaces, handle optional sign, parse digits while converting from ASCII, and check for overflow/underflow before updating the result. |Math:<br> $O(n)$|Math:<br> $O(1)$|
| 9  | [Palindrome Number](https://leetcode.com/problems/palindrome-number/) | Medium    | <b>Math:</b><br>[C#](./algorithms/cs/9_Math.cs) | Math:<br> Reject negatives and numbers ending in 0 (except 0 itself). Reverse half the digits and compare with the remaining half to check if it forms a palindrome.  |Math:<br> $O(\log n)$|Math:<br> $O(1)$|
| 11  | [Container With Most Water](https://leetcode.com/problems/container-with-most-water/) | Medium    | <b>Two Pointers:</b><br>[C#](./algorithms/cs/11_TwoPointers.cs)<br>[C++](./algorithms/cpp/11_TwoPointers.cpp) | Two Pointers:<br> Use two pointers at the start and end of array, contract the container by the lower wall's side. |Two Pointers:<br> $O(n)$|Two Pointers:<br> $O(1)$|
| 13  | [Roman to Integer](https://leetcode.com/problems/roman-to-integer/) | Easy    | <b>Hashing:</b><br>[C++](./algorithms/cpp/13_Hashing.cpp) | Hashing:<br> If the next numeral is larger then subtract the current one, else add it. |Hashing:<br> $O(n)$|Hashingp:<br> $O(1)$|
| 15 | [3Sum](https://leetcode.com/problems/3sum/) | Medium | <b>Sorting + Two Pointers</b><br>[C++](./algorithms/cpp/15_TwoPointers.cpp) | Sorting + Two Pointers:<br>Sort the array. For each element as the fixed value, use two pointers to find remaining elements that sum to zero. Skip duplicates. | Sorting + Two Pointers:<br>$O(n^2)$ | Sorting + Two Pointers:<br>$O(1)$ |
| 16 | [3Sum Closest](https://leetcode.com/problems/3sum-closest/) | Medium | <b>Sorting + Two Pointers</b><br>[C++](./algorithms/cpp/16_TwoPointers.cpp) | Sorting + Two Pointers:<br>Sort the array. For each element as the fixed value, use two pointers to find the closest sum to the target. Update the closest result accordingly. | Sorting + Two Pointers:<br>$O(n^2)$ | Sorting + Two Pointers:<br>$O(1)$ |
| 17  | [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) | Medium    |<b>Backtracking:</b><br> [C++ Recursive](./algorithms/cpp/17_Recursive.cpp)<br>[Python Iterative](./algorithms/py/17_BacktrackingIterative.py) | Backtracking:<br> Use backtracking to explore all possible combinations. For each digit, try every letter it maps to by appending one letter at a time to a growing combination. Once a combination reaches the same length as the input, add it to the result. After exploring each path, remove the last letter to backtrack and try the next possibility.|Backtracking:<br> $O(3^n \cdot 4^m)$<br>`n` is the number of digits in the input string that map to 3 letters<br>`m` is the number of digits that map to 4 letters| Backtracking:<br> $O(3^n \cdot 4^m)$|
| 19 | [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) | Medium | <b>Two Pointers</b><br>[C++](./algorithms/cpp/19_TwoPointers.cpp) | Two Pointers:<br>Use a dummy node and two pointers (`fast` and `slow`). Advance `fast` by `n + 1` steps so that `slow` points to the node before the one to remove when `fast` reaches the end. This allows for one-pass deletion. | Two Pointers:<br>$O(n)$ | Two Pointers:<br>$O(1)$ |
| 20 | [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) | Easy | <b>Stack</b><br>[C++ with Map](./algorithms/cpp/20_StackMap.cpp)<br>[C++ without Map](./algorithms/cpp/20_StackNoMap.cpp) | Stack:<br>Use a stack to track opening brackets. One version uses a map for bracket pairs, while the other uses conditionals for performance and simplicity given only three bracket types. | Stack:<br>$O(n)$ | Stack:<br>$O(n)$ |
| 21 | [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | Easy | <b>Pointers</b><br>[Python](./algorithms/py/21_Pointers.py) | Pointers:<br> Merge two sorted linked lists by iterating through both and adjusting pointers. Use a dummy node to simplify edge cases. | Pointers:<br>$O(n + m)$<br>`n` and `m` are the lengths of the two input lists | Pointers:<br>$O(1)$ |
| 22 | [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) | Medium | <b>Backtracking</b><br>[C++ Recursive](./algorithms/cpp/22_BacktrackingRecursive.cpp)<br>[C++ Iterative](./algorithms/cpp/22_BacktrackingIterative.cpp) | Backtracking:<br>Use backtracking to generate all combinations of well-formed parentheses. Track the number of opening and closing parentheses used so far. Only add a closing parenthesis if it won't lead to invalid syntax. | Backtracking:<br>$O(n \cdot 4^n)$<br>`n` is the number of pairs of parentheses. | Backtracking:<br>$O(n)$ |
| 27  | [Remove Element](https://leetcode.com/problems/remove-element/) | Easy | <b>Two Pointers:</b><br>[C++](./algorithms/cpp/27_TwoPointers.cpp) | Two Pointers:<br> Use one pointer to scan all elements, and another to overwrite non-target values in-place. Return the new length of the array. |Two Pointers:<br> $O(n)$|Two Pointers:<br> $O(1)$|
| 28 | [Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/) | Easy | <b>Brute Force:</b><br>[C++](./algorithms/cpp/28_BruteForce.cpp) | Brute Force:<br>Try all possible start indices in the haystack. At each index, compare characters of needle one by one. Return the first matching index, or -1 if not found. | Brute Force:<br>$O(n \cdot m)$<br>`n` is the length of haystack<br>`m` is the length of needle. | Brute Force:<br>$O(1)$ |
| 34 | [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | Medium | <b>Binary Search:</b><br>[Python](./algorithms/py/34_BinarySearch.py) | Binary Search:<br>Use binary search twice—once to find the leftmost (first) occurrence and once to find the rightmost (last) occurrence of the target value in the sorted array. | Binary Search:<br>$O(\log n)$ | Binary Search:<br>$O(1)$ |
| 35  | [Search Insert Position](https://leetcode.com/problems/search-insert-position/) | Easy    | <b>Binary Search:</b><br>[C++](./algorithms/cpp/35_BinarySearch.cpp) | Binary Search:<br> Binary search approach, remember to update the left and right pointers PAST the middle pointer. |Binary Search:<br> $O(\log n)$|Binary Search:<br> $O(1)$|
| 36  | [Valid Sudoku](https://leetcode.com/problems/valid-sudoku/) | Medium | <b>Hashing:</b><br>[Python Set](./algorithms/py/36_Set.py)<br><br><b>Brute Force:</b><br>[Python Cell](./algorithms/py/36_Cell.py) | Hashing:<br> Use three arrays of sets to track values seen in rows, columns, and 3×3 boxes. Insert and check each value once. <br>Box index is calculated as $(i \mathbin{//} 3) \cdot 3 + (j \mathbin{//} 3)$.<br><br>Brute Force:<br> For each non-empty cell, scan its row, column, and box directly to check for duplicates. This avoids extra space but involves repeated comparisons. |Hashing:<br> $O(1)$<br><br>Brute Force:<br> $O(1)$|Hashing:<br> $O(1)$<br><br>Brute Force:<br> $O(1)$|
| 38 | [Count and Say](https://leetcode.com/problems/count-and-say/) | Medium | <b>Simulation</b><br>[C++](./algorithms/cpp/38_Simulation.cpp) | Simulation:<br>Start from the string "1" and iterate `n - 1` times. For each iteration, scan the current string and count consecutive repeating digits. Construct the next string by appending the count followed by the digit. | Simulation:<br>$O(n \cdot 2^n)$ | Simulation:<br>$O(2^n)$ |
| 39 | [Combination Sum](https://leetcode.com/problems/combination-sum/) | Medium | <b>Backtracking:</b><br>[C++ Recursive](./algorithms/cpp/39_BacktrackingRecursive.cpp) | Backtracking:<br> Use backtracking to explore all combinations of candidates that sum to the target. At each step, choose a candidate and continue from the same index (allowing reuse). Backtrack by removing the last number after exploring a path. | Backtracking:<br>$O(2^n)$ | Backtracking:<br>$O(2^n)$ |
| 41 | [First Missing Positive](https://leetcode.com/problems/first-missing-positive/) | Hard | <b>Index Placement:</b><br>[C++](./algorithms/cpp/41_IndexPlacement.cpp) | Index Placement:<br>Rearrange the array so that each positive integer `x` is placed at index `x - 1` if possible. After placement, the first index `i` where `nums[i] != i + 1` is the smallest missing positive. | Index Placement:<br>$O(n)$ | Index Placement:<br>$O(1)$ |
| 55 | [Jump Game](https://leetcode.com/problems/jump-game/) | Medium | <b>Greedy:</b><br>[C++](./algorithms/cpp/55_Greedy.cpp) | Greedy:<br>Iterate through the array while maintaining the farthest index that can be reached. If the current index exceeds the maximum reachable index, return false. Otherwise, keep updating the maximum reach. | Greedy:<br>$O(n)$ | Greedy:<br>$O(1)$ |
| 58 | [Length of Last Word](https://leetcode.com/problems/length-of-last-word/) | Easy | <b>Iterative:</b><br>[C++](./algorithms/cpp/58_Iterative.cpp) | Iterative:<br>Iterate from the end of the string, skip trailing spaces, then count the length of the last word until the next space or the beginning of the string. | Iterative:<br>$O(n)$ | Iterative:<br>$O(1)$ |
| 66 | [Plus One](https://leetcode.com/problems/plus-one/) | Easy | <b>Math:</b><br>[C++](./algorithms/cpp/66_Math.cpp) | Math:<br>Start from the least significant digit and simulate addition with carry. Increment each digit, and if it becomes 10, set it to 0 and continue. If carry remains after processing all digits, insert 1 at the beginning of the array. | Maths:<br>$O(n)$ | Math:<br>$O(1)$ |
| 67 | [Add Binary](https://leetcode.com/problems/add-binary/) | Easy | <b>Bit Manipulation:</b><br>[Python](./algorithms/py/67_BitManipulation.py) | Bit Manipulation:<br>Simulate binary addition from right to left by counting the number of ones (`1`s) including the carry, and determine the next digit and new carry based on the count. Reverse and join the result list at the end. | Bit Manipulation:<br>$O(\max(n, m))$<br>`n` is the length of string `a`<br>`m` is the length of string `b` |Bit Manipulation:<br>$O(\max(n, m))$ |
| 69 | [Sqrt(x)](https://leetcode.com/problems/sqrtx/) | Easy | <b>Binary Search:</b><br>[Python](./algorithms/py/69_BinarySearch.py) | Binary Search:<br>Use binary search to find the largest integer whose square is less than or equal to `x`. Search in the range [0, x] and return the highest `mid` such that `mid * mid <= x`. | Binary Search:<br>$O(\log x)$ | Binary Search:<br>$O(1)$ |
| 75 | [Sort Colors](https://leetcode.com/problems/sort-colors/) | Medium | <b>Three Pointers:</b><br>[C++](./algorithms/cpp/75_ThreePointers.cpp) | Three Pointers:<br>Use the Dutch National Flag algorithm to sort the array in a single pass. Maintain three pointers for the positions of 0s, 1s, and 2s, and swap elements accordingly. | Three Pointers:<br>$O(n)$ | Three Pointers:<br>$O(1)$ |
| 77 | [Combinations](https://leetcode.com/problems/combinations/) | Medium | <b>Backtracking:</b><br>[Python Iterative](./algorithms/py/77_BacktrackingIterative.py) | Backtracking:<br>Use backtracking to build all combinations of size `k` from numbers 1 to `n`. At each step, choose the next number greater than the last to avoid duplicates. Add to the result when the combination reaches length `k`. | Backtracking:<br>$O(k \cdot \binom{n}{k})$ | Backtracking:<br>$O(k \cdot \binom{n}{k})$ |
| 78 | [Subsets](https://leetcode.com/problems/subsets/) | Medium | <b>Backtracking:</b><br>[Python Iterative](./algorithms/py/78_BacktrackingIterative.py) | Backtracking:<br>Use backtracking to explore all possible subsets of the input array. At each step, decide whether to include the current element and proceed to the next index. Add each partial subset to the result as it represents a valid subset. <br>The power set of a list with `n` elements contains $2^n$ subsets, including the empty set. | Backtracking:<br>$O(2^n \cdot n)$ | Backtracking:<br>$O(2^n \cdot n)$ |
| 94 | [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/) | Easy | <b>DFS:</b><br>[C++ Recursive](./algorithms/cpp/94_Recursive.cpp) | DFS:<br>Traverse the tree using depth-first search in inorder sequence: left subtree → node → right subtree. Add each visited value to the result list. | DFS:<br>$O(n)$ | DFS:<br>$O(h)$<br>`h` is the height of the tree |
| 100 | [Same Tree](https://leetcode.com/problems/same-tree/) | Easy | <b>DFS:</b><br>[C++ Recursive](./algorithms/cpp/100_DFSRecursive.cpp)<br>[Python Recursive](./algorithms/py/100_DFSRecursive.py)<br><br><b>BFS:</b><br>[Python Iterative](./algorithms/py/100_BFSIterative.py) | DFS: Traverse both trees in depth-first order. At each step, check if both nodes exist and have the same value, then compare their children.<br><br>BFS: Use a queue to traverse both trees level by level. At each step, check if both nodes exist, match in value, and enqueue their children accordingly. | DFS: $O(n)$<br><br>BFS: $O(n)$ | DFS: $O(h)$<br>`h` is the height of the tree<br><br>BFS: $O(w)$<br>`w` is the max width of the tree |
| 101 | [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/) | Easy | <b>DFS:</b><br>[C++ Recursive](./algorithms/cpp/101_DFSRecursive.cpp)<br>[Python Recursive](./algorithms/py/101_DFSRecursive.py)<br><br><b>BFS:</b><br>[Python Iterative](./algorithms/py/101_BFSIterative.py) | DFS:<br> Compare the left and right subtrees in mirrored order. At each step, check whether both nodes exist, match in value, and their children are symmetric.<br><br>BFS:<br> Traverse the tree level by level using a queue of node pairs. For each pair, check for symmetry and enqueue mirrored child nodes. | DFS: $O(n)$<br><br>BFS: $O(n)$ | DFS: $O(h)$<br>`h` is the height of the tree<br><br>BFS: $O(w)$<br>`w` is the max width of the tree |
| 102 | [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) | Medium | <b>BFS:</b><br>[Python Iterative](./algorithms/py/102_BFSIterative.py) | BFS:<br>Use breadth-first search with a queue to traverse the tree level by level. Group the node values from each level into sublists for the final result. | BFS:<br>$O(n)$ | BFS:<br>$O(w)$<br>`w` is the maximum width of the tree |
| 103 | [Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/) | Medium | <b>BFS:</b><br>[Python Iterative](./algorithms/py/103_BFSIterative.py) | BFS:<br>Use breadth-first search to traverse the tree level by level. Alternate the direction of traversal at each level to create the zigzag pattern. | BFS:<br>$O(n)$ | BFS:<br>$O(w)$<br>`w` is the maximum width of the tree |
| 104 | [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | Easy | <b>DFS:</b><br>[C++ Recursive](./algorithms/cpp/104_DFSRecursive.cpp)<br><br><b>BFS:</b><br>[Python Iterative](./algorithms/py/104_BFSIterative.py) | DFS:<br> Traverse the tree depth-first, computing the depth of left and right subtrees, and returning the maximum plus one.<br><br>BFS:<br> Traverse level by level using a queue, counting the number of levels to determine depth. | DFS: $O(n)$<br><br>BFS: $O(n)$ | DFS: $O(h)$, where `h` is the height of the tree<br><br>BFS: $O(w)$<br>`w` is the max width of the tree |
| 107 | [Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/) | Medium | <b>BFS:</b><br>[Python Iterative](./algorithms/py/107_BFSIterative.py) | BFS:<br>Use breadth-first search to traverse the tree level by level. Collect nodes from each level and prepend to the result to produce bottom-up order. | BFS:<br>$O(n)$ | BFS:<br>$O(w)$<br>`w` is the maximum width of the tree |
| 111 | [Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/) | Easy | <b>DFS:</b><br>[C++ Recursive](./algorithms/cpp/111_DFSRecursive.cpp)<br><br><b>BFS:</b><br>[Python Iterative](./algorithms/py/111_BFSIterative.py) | DFS:<br> Recursively find the minimum depth by comparing the depths of left and right subtrees. Handle cases where one child is null.<br><br>BFS:<br> Traverse the tree level by level and return the depth when the first leaf node is encountered. | DFS:<br> $O(n)$<br><br>BFS:<br> $O(n)$ | DFS: $O(h)$<br>`h` is the height of the tree<br><br>BFS: $O(w)$<br>`w` is the maximum width of the tree |
| 112 | [Path Sum](https://leetcode.com/problems/path-sum/) | Easy | <b>DFS:</b><br>[C++ Recursive](./algorithms/cpp/112_Recursive.cpp)<br>[Python Iterative](./algorithms/py/112_DFSIterative.py) | DFS:<br>Use depth-first search to traverse the tree while tracking the remaining target sum. At each node, subtract its value from the remaining sum. Return true if a leaf node is reached and the remaining sum is zero. | DFS:<br>$O(n)$ | DFS:<br>$O(h)$<br>`h` is the height of the tree |
| 118 | [Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/) | Easy | <b>Iterative:</b><br>[C++](./algorithms/cpp/118_Iterative.cpp) | Iterative:<br>Construct each row of Pascal's Triangle iteratively. Initialize each row with 1s, then fill internal values using the sum of the two elements directly above. | Iterative:<br>$O(n^2)$ | Iterative:<br>$O(n^2)$ |
| 119 | [Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/) | Easy | <b>Iterative Two Rows:</b><br>[C++](./algorithms/cpp/119_TwoRows.cpp)<br><br><b>Iterative One Row:</b><br>[C++](./algorithms/cpp/119_OneRow.cpp) | Iterative Two Rows:<br> Use two vectors to compute each row based on the previous one. Only store the previous row to save space.<br><br>Iterative One Row:<br> Use a single vector and update it in reverse to reuse values from the same row without overwriting needed data. | Iterative Two Rows:<br>$O(n^2)$<br><br>Iterative One Row:<br>$O(n^2)$ | Iterative Two Rows:<br>$O(n)$<br><br>Iterative One Row:<br>$O(n)$ |
| 121 | [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) | Easy | <b>Greedy:</b><br>[C++](./algorithms/cpp/121_Greedy.cpp) | Greedy:<br>Track the minimum price seen so far while iterating through the array. At each step, calculate the potential profit and update the maximum profit if it's higher. | Greedy:<br>$O(n)$ | Greedy:<br>$O(1)$ |
| 122 | [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) | Medium | <b>Greedy:</b><br>[C++](./algorithms/cpp/122_Greedy.cpp) | Greedy:<br>Use a greedy strategy to accumulate profit by adding the difference between every consecutive day where the price increases. | Greedy:<br>$O(n)$ | Greedy:<br>$O(1)$ |
| 125 | [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) | Easy | <b>Two Pointers:</b><br>[C++](./algorithms/cpp/125_TwoPointers.cpp) | Two Pointers:<br> Use two pointers to scan the string from both ends. Skip non-alphanumeric characters and compare characters case-insensitively. If all valid characters match symmetrically, the string is a palindrome. | Two Pointers:<br>$O(n)$ | Two Pointers:<br>$O(1)$ |
| 136 | [Single Number](https://leetcode.com/problems/single-number/) | Easy | <b>Bit Manipulation:</b><br>[C++](./algorithms/cpp/136_XOR.cpp) | Bit Manipluation:<br>XOR all elements in the array. Duplicate elements cancel each other out, so the final result is the number that appears only once. Order and position do not affect the XOR operation. | Bit Manipulation:<br>$O(n)$ | Bit Manipulation:<br>$O(1)$ |
| 141 | [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) | Easy | <b>Two Pointers (Floyd’s Algorithm):</b><br>[C++](./algorithms/cpp/141_FloydsCycleDetection.cpp) | Two Pointers (Floyd’s Algorithm):<br>Use two pointers moving at different speeds (`slow` and `fast`). If there is a cycle, the fast pointer will eventually meet the slow pointer. If the fast pointer reaches the end, there is no cycle. | Two Pointers (Floyd’s Algorithm):<br>$O(n)$ | Two Pointers (Floyd’s Algorithm):<br>$O(1)$ |
| 144 | [Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/) | Easy | <b>DFS (Preorder):</b><br>[C++ Recursive](./algorithms/cpp/144_Recursive.cpp) | DFS (Preorder):<br>Traverse the tree using depth-first search in preorder sequence: visit the current node, then traverse the left and right subtrees. | DFS (Preorder):<br>$O(n)$ | DFS (Preorder):<br>$O(h)$<br>`h` is the height of the tree |
| 145 | [Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/) | Easy | <b>DFS (Postorder):</b><br>[C++](./algorithms/cpp/145_Recursive.cpp) | DFS (Postorder):<br>Traverse the tree using depth-first search in postorder sequence: traverse the left and right subtrees first, then visit the current node. | DFS (Postorder):<br>$O(n)$ | DFS (Postorder):<br>$O(h)$<br>`h` is the height of the tree |
| 167 | [Two Sum II – Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) | Medium | <b>Two Pointers:</b><br>[C++](./algorithms/cpp/167_TwoPointers.cpp) | Two Pointers:<br>Use two pointers starting from both ends of the array. Move the left pointer forward if the sum is too small, or the right pointer backward if the sum is too large, until the target is found. | Two Pointers:<br>$O(n)$ | Two Pointers:<br>$O(1)$ |
| 169 | [Majority Element](https://leetcode.com/problems/majority-element/) | Medium | <b>Hashing</b><br>[C++](./algorithms/cpp/169_Hashing.cpp)<br><br><b>Sorting</b><br>[C++](./algorithms/cpp/169_Sorting.cpp) | Hashing:<br> Count the frequency of each number and return the one with count greater than ⌊n / 2⌋.<br><br>Sorting:<br> Sort the array; the majority element is guaranteed to be at the middle index. | Hashing:<br> $O(n)$<br><br>Sorting:<br> $O(n \log n)$ | Hashing:<br> $O(n)$<br><br>Sorting:<br> $O(1)$ |
| 200 | [Number of Islands](https://leetcode.com/problems/number-of-islands/) | Medium | <b>DFS:</b><br>[Python with set Iterative](./algorithms/py/200_DFSIterativeSet.py)<br>[Python in-place Iterative](./algorithms/py/200_DFSIterativeInPlace.py) | DFS:<br>Explore all connected land cells using depth-first search. The set-based version tracks visited cells explicitly. The in-place version marks visited cells by overwriting `'1'` with `'0'`. Each new unvisited land cell triggers a new island count. | DFS:<br>$O(m \times n)$<br>`m` is the number of rows<br>`n` is the number of columns in the grid. | DFS:<br>With set: $O(m \times n)$<br>In-place: $O(1)$ |
| 202 | [Happy Number](https://leetcode.com/problems/happy-number/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/202_HashSet.cpp) | Hashing:<br>Use a hash set to detect cycles in the sequence of digit square sums. If a sum repeats, the number is not happy. If the sequence reaches 1, it's a happy number. | Hashing:<br>$O(\log n)$ per number<br>`n` is the input value | Hashing:<br>$O(\log n)$ |
| 205 | [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/) | Easy | <b>Hashing</b><br>[Python](./algorithms/py/205_Hashing.py)<br>[C++](./algorithms/cpp/205_Hashing.cpp) | Hashing:<br>Use two hash maps to enforce a one-to-one character mapping between the strings. For each character pair, check that the mapping is consistent in both directions. If a conflict is found, return false. Insert new mappings as needed. | Hashing:<br>$O(n)$ | Hashing:<br>$O(n)$ |
| 206 | [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) | Easy | <b>Iterative:</b><br>[Python](./algorithms/py/206_Iterative.py)<br>[C++](./algorithms/cpp/206_Iterative.cpp) | Iterative:<br>Traverse the list while reversing the direction of each link one by one. Maintain a `prev` pointer and update `head->next` to point to `prev` at each step. Set the original head’s next to `null` to avoid cycles. | Iterative:<br>$O(n)$ | Iterative:<br>$O(1)$ |
| 217 | [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) | Easy | <b>Hashing</b><br>[C++](./algorithms/cpp/217_Hashing.cpp)<br><br><b>Sorting</b><br>[C++](./algorithms/cpp/217_Sorting.cpp) | Hashing:<br> Use a hash set to track seen numbers. If a number is already in the set, return true.<br><br>Sorting:<br> Sort the array and check for adjacent duplicates. If any two consecutive elements are equal, return true. | Hashing:<br> $O(n)$<br><br>Sorting:<br> $O(n \log n)$ | Hashing:<br> $O(n)$<br><br>Sorting:<br> $O(1)$ |
| 219 | [Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/219_Hashing.cpp) | Hashing:<br>Use a hash map to store the most recent index of each number. For each element, check whether it has appeared before within a distance of `k`. Return true if such a pair exists; otherwise, update the stored index. | Hashing:<br>$O(n)$ | Hashing:<br>$O(n)$ |
| 222 | [Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/) | Easy | <b>DFS (Naive)</b><br>[C++](./algorithms/cpp/222_Recursive.cpp)<br><br><b>Binary Search on Tree Height</b><br>[C++](./algorithms/cpp/222_BinarySearchOnTreeHeight.cpp) | DFS (Naive):<br> Traverse every node recursively and increment a counter. This runs in $O(n)$ time and does not exploit the complete tree structure.<br><br>Binary Search on Tree Height:<br> Use properties of a complete binary tree. If the heights of the left and right subtrees are equal, the left subtree is perfect and its size can be computed directly. Recurse only into the incomplete side. | DFS (Naive):<br> $O(n)$<br><br>Binary Search on Tree Height:<br> $O((\log n)^2)$ | DFS (Naive):<br> $O(h)$<br>Binary Search on Tree Height:<br> $O(\log n)$ |
| 225 | [Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/) | Easy | <b>Stack Simulation</b><br>[C++](./algorithms/cpp/225_StackSimulation.cpp) | Stack Simulation:<br>Use a single queue. On `push`, add the new element to the back and rotate the existing elements to the back to maintain LIFO order. This ensures the top of the stack is always at the front of the queue. | Stack Simulation:<br>`push`: $O(n)$<br>`pop`, `top`, `empty`: $O(1)$ | Stack Simulation:<br>$O(n)$ |
| 232  | [Implement Queue using Stacks](https://leetcode.com/problems/product-of-array-except-self/) | Easy    | <b>Queue Simulation:</b><br>[C++](./algorithms/cpp/232_QueueSimulation.cpp) | Queue Simulation:<br> Use two stacks to implement a queue with amortized $O(1)$ operations. Push to an input stack. For `pop` and `peek`, transfer elements to the output stack only when it’s empty. This ensures each element is moved at most once. |Queue Simulation:<br>Amortized: all operations $O(1)$ N/A |Queue Simulation:<br> $O(n)$ |
| 238 | [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/) | Medium | <b>Prefix & Suffix Products:</b><br>[Python](./algorithms/py/238_TwoPasses.py) | Prefix & Suffix Products:<br>Use a two-pass approach. First, compute prefix products from left to right. Then, compute suffix products from right to left and multiply them into the result array. No division is used. | Prefix & Suffix Products:<br>$O(n)$ | Prefix & Suffix Products:<br>$O(1)$|
| 242 | [Valid Anagram](https://leetcode.com/problems/valid-anagram/) | Easy | <b>Sorting</b><br>[C++](./algorithms/cpp/242_Sorting.cpp)<br><br><b>Hashing</b><br>[C++](./algorithms/cpp/242_Hashing.cpp)<br><br><b>Fixed-Size Array</b><br>[C++](./algorithms/cpp/242_FixedSizeArray.cpp) | Sorting:<br> Sort both strings and compare equality.<br><br>Hashing:<br> Count character frequencies in both strings. Subtract one from the other and verify all counts are zero.<br><br>Fixed-Size Array:<br> Use a 26-element array to track character frequencies. Only valid for lowercase English letters. | Sorting:<br> $O(n \log n)$<br><br>Hashing:<br> $O(n)$<br><br>Fixed-Size Array:<br> $O(n)$ | Sorting:<br> $O(1)$<br><br>Hashing:<br> $O(n)$<br><br>Fixed-Size Array:<br> $O(1)$ |
| 263 | [Ugly Number](https://leetcode.com/problems/ugly-number/) | Easy | <b>Math:</b><br>[C++](./algorithms/cpp/263_Recursive.cpp) | Math:<br>Recursively divide the number by 2, 3, and 5. If the number can be reduced to 1 using only these factors, it is considered an ugly number. | Math:<br>$O(\log n)$ | Math:<br>$O(\log n)$ |
| 268 | [Missing Number](https://leetcode.com/problems/missing-number/) | Easy | <b>Boolean Vector:</b><br>[C++](./algorithms/cpp/268_Vector.cpp)<br><br><b>Math:</b><br>[C++](./algorithms/cpp/268_Math.cpp)<br><br><b>Bit Manipulation:</b><br>[C++](./algorithms/cpp/268_BitManipulation.cpp) | Boolean Vector:<br> Use a boolean array of size `n + 1` to track presence of each number from 0 to `n`. Return the index that is still false.<br><br>Math:<br> Use the formula `n(n + 1)/2` to compute the expected sum of numbers from 0 to `n`. Subtract the actual sum to find the missing number.<br><br>Bit Manipulation:<br> XOR all the numbers from 0 to `n` and all elements in the array. Paired values cancel out, leaving the missing number. | Boolean Vector:<br> $O(n)$<br><br>Math:<br>$O(n)$<br><br>Bit Manipulation:<br>$O(n)$| Boolean Vector: $O(n)$<br><br>Math:<br> $O(1)$<br><br>Bit Manipulation:<br> $O(1)$ |
| 274 | [H-Index](https://leetcode.com/problems/h-index/) | Medium | <b>Binary Search:</b><br>[Python](./algorithms/cpp/274_BinarySearch.cpp) | Binary Search:<br>Sort the citations array. Use binary search to find the smallest index `i` such that `citations[i] ≥ n - i`. The H-index is `n - i`, meaning there are at least `n - i` papers with that many or more citations. | Binary Search:<br>$O(n \log n)$ | Binary Search:<br>$O(1)$ |
| 278 | [First Bad Version](https://leetcode.com/problems/first-bad-version/) | Easy | <b>Binary Search:</b><br>[C++](./algorithms/cpp/278_BinarySearch.cpp) | Binary Search:<br>Use binary search to find the first version that returns true from the `isBadVersion` API. Check if `mid` is bad and `mid - 1` is not; if so, return `mid`. Otherwise, adjust the search range accordingly. |Binary Search:<br> $O(\log n)$ | Binary Search:<br>$O(1)$ |
| 283 | [Move Zeroes](https://leetcode.com/problems/move-zeroes/) | Easy | <b>Two Pointers:</b><br>[Python](./algorithms/py/283_TwoPointers.py) | Two Pointers:<br>Use two pointers: one to iterate through the array, and another to track the position to write non-zero elements. After placing all non-zero values, fill the remaining slots with zeroes. This minimizes operations and works in-place. | Two Pointers:<br>$O(n)$ | Two Pointers:<br>$O(1)$ |
| 290 | [Word Pattern](https://leetcode.com/problems/word-pattern/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/290_Hashing.cpp) | Hashing:<br>Use two hash maps to ensure a one-to-one correspondence (bijection) between pattern characters and words in the input string. Validate that both mappings are consistent and no character or word is reused. | Hashing:<br>$O(n)$ | Hashing:<br>$O(n)$ |
| 338 | [Counting Bits](https://leetcode.com/problems/counting-bits/) | Easy | <b>Dynamic Programming:</b><br>[C++](./algorithms/cpp/338_Tabulation.cpp) | Dynamic Programming:<br>Use bottom-up dynamic programming. For each number `i`, the count of 1’s is `dp[i >> 1] + (i & 1)` — that is, the count of 1’s in `i / 2` plus 1 if `i` is odd. Build the result incrementally. | Dynamic Programming:<br>$O(n)$ | Dynamic Programming:<br>$O(n)$ |
| 344  | [Reverse String](https://leetcode.com/problems/reverse-string/) | Easy    | [Python](./algorithms/py/344_TwoPointers.py) | Python: Use two pointers (`left` and `right`) to swap characters in-place until the middle is reached. |Python: $O(n)$|Python: $O(1)$|
| 344 | [Reverse String](https://leetcode.com/problems/reverse-string/) | Easy | <b>Two Pointers</b><br>[Python](./algorithms/py/344_TwoPointers.py) | Two PointersUse two pointers (`left` and `right`) to swap characters in-place until they meet in the middle. | $O(n)$ | $O(1)$ |
| 345 | [Reverse Vowels of a String](https://leetcode.com/problems/reverse-vowels-of-a-string/) | Easy | <b>Two Pointers:</b><br>[C++](./algorithms/cpp/345_TwoPointers.cpp) | Two Pointers:<br>Use two pointers to move inward from both ends of the string. Swap characters only when both pointers are at vowels. Skip non-vowels using a hash set for constant-time lookup. | Two Pointers:<br>$O(n)$ | Two Pointers:<br>$O(1)$ |
| 349 | [Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/349_Hashing.cpp)<br>[Python](./algorithms/py/349_Hashing.py) | Hashing:<br>Use a hash set to store unique elements from one array. Then iterate through the other and insert shared elements into a result set. | Hashing:<br>$O(n + m)$ | Hashing:<br>$O(n + m)$ |
| 367 | [Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square/) | Easy | <b>Binary Search:</b><br>[Python](./algorithms/py/367_BinarySearch.py) | Binary Search:<br> Use binary search to find an integer whose square equals the input. Adjust the search space by comparing `mid * mid` with the target value. |Binary Search:<br> $O(\log n)$ | Binary Search:<br>$O(1)$ |
| 374 | [Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/) | Easy | <b>Binary Search:</b><br>[C++](./algorithms/cpp/374_BinarySearch.cpp) | Binary Search:<br> Use binary search to minimize the number of API calls. Narrow the search space by adjusting bounds based on whether the guess was too high or too low. | Binary Search:<br>$O(\log n)$ | Binary Search:<br>$O(1)$ |
| 383 | [Ransom Note](https://leetcode.com/problems/ransom-note/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/383_Hashing.cpp) | Hashing:<br>Use a hash map to count character frequencies in the magazine. For each character in the ransom note, decrement the count. If any count falls below zero, return false. | Hashing:<br>$O(m + n)$<br>`m` is the length of the ransom note<br>`n` is the length of the magazine | Hashing:<br>$O(m)$ |
| 387 | [First Unique Character in a String](https://leetcode.com/problems/first-unique-character-in-a-string/) | Easy | <b>Fixed-Size Array:</b><br>[Python](./algorithms/py/387_FixedSizeArray.py) | Fixed-Size Array:<br>Use a fixed-size array of 26 elements to count character occurrences. Then scan the string to find the first character with frequency 1. This avoids hash map overhead. | Fixed-Size Array:<br>$O(n)$| Fixed-Size Array:<br>$O(1)$ |
| 389 | [Find the Difference](https://leetcode.com/problems/find-the-difference/) | Easy | <b>Sorting:</b><br>[C++](./algorithms/cpp/389_Sorting.cpp)<br><br><b>Fixed Size Array:</b><br>[C++](./algorithms/cpp/389_FixedSizeArray.cpp)<br><br><b>Bit Manipulation:</b><br>[C++](./algorithms/cpp/389_BitManipulation.cpp) | Sorting:<br>Sort both strings and compare character by character to find the mismatch.<br><br>Fixed-Size Array:<br> Use a fixed-size array of 26 integers to count character frequencies in string `s`. Then decrement counts using string `t`. The first character whose count becomes negative is the added character.<br><br>Bit Manipulation:<br> XOR all characters from both strings; the result is the extra character due to XOR cancellation. | Sorting: <br>$O(n \log n)$<br><br>Fixed-Size Array: <br>$O(n)$<br><br>Bit Manipulation:<br> $O(n)$ | Sorting: <br>$O(m)$<br><br>Fixed-Size Array:<br> $O(1)$<br><br>Bit Manipulation: $O(1)$ |
| 392 | [Is Subsequence](https://leetcode.com/problems/is-subsequence/) | Easy | <b>Two Pointers:</b><br>[C++](./algorithms/cpp/392_TwoPointers.cpp) | Two Pointers:<br>Use a greedy two-pointer approach. Iterate through `t` and try to match each character in `s` in order. If all characters in `s` are matched before `t` is exhausted, return true. | Two Pointers:<br>$O(n)$<br>`n` is the length of `t` | Two Pointers:<br>$O(1)$ |
| 404 | [Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves/) | Easy | <b>DFS:</b><br>[C++ Recursive](./algorithms/cpp/404_Recursive.cpp) | DFS:<br> Traverse the binary tree and keep track of whether each visited node is a left child. If a node is a leaf and it is also a left child, add its value to the total sum. Ignore right leaves and internal nodes. | DFS:<br>$O(n)$ | DFS:<br>$O(h)$<br>`h` is the height of the tree |
| 412 | [Fizz Buzz](https://leetcode.com/problems/fizz-buzz/) | Easy | <b>Iterative:</b><br>[C++](./algorithms/cpp/412_Iterative.cpp) | Iterative:<br>Use an iterative loop from 1 to n. At each step, check divisibility rules and build the result string accordingly. | Iterative:<br>$O(n)$ | Iterative:<br>$O(n)$ |
| 433 | [Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/) | Medium | <b>BFS on Graph:</b><br>[Python Iterative](./algorithms/py/433_BFSIterativeGraph.py) | BFS on Graph:<br>Model each gene as a node in a graph. Create edges between genes that differ by exactly one character. Use BFS to find the shortest mutation path from `startGene` to `endGene`. | BFS on Graph:<br>$O(n^2 \cdot l)$<br>`n` is the number of genes<br>`l` is gene length (fixed at 8) | BFS on Graph:<br>$O(n^2)$ |
| 443 | [String Compression](https://leetcode.com/problems/string-compression/) | Medium | <b>Two Pointers:</b><br>[Python](./algorithms/py/443_TwoPointers.py) | Two Pointers:<br>Use two pointers to compress the array in-place. Read and count consecutive characters, then write the character and its count (if > 1) back into the array. Return the final length of the compressed string. | Two Pointers:<br>$O(n)$ | Two Pointers:<br>$O(1)$ |
| 513  | [Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/) | Easy    | [C++](./algorithms/cpp/513_Recursive.cpp) | C++: Use a recursive DFS approach, to ensure the left-most value among the last row is encountered first. |C++: $O(n)$|C++: $O(h)$|
| 513 | [Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/) | Easy | <b>DFS:</b><br>[C++ Recursive](./algorithms/cpp/513_Recursive.cpp) | DFS:<br>Traverse the binary tree and track the current depth. Update the result when reaching a deeper leaf. Since traversal favors the left subtree first, the first node at the deepest level is guaranteed to be the leftmost. | DFS:<br>$O(n)$ | DFS:<br>$O(h)$<br>`h` is the height of the tree |
| 605 | [Can Place Flowers](https://leetcode.com/problems/can-place-flowers/) | Easy | <b>Greedy:</b><br>[C++](./algorithms/cpp/605_Greedy.cpp) | Greedy:<br>Traverse the flowerbed and greedily plant flowers where possible (i.e., both neighbors are 0 or out-of-bounds). After planting, skip the next index to respect the no-adjacency rule. Return true if at least `n` flowers can be planted. | Greedy:<br>$O(n)$ | Greedy:<br>$O(1)$ |
| 637 | [Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/) | Easy | <b>DFS:</b><br>[C++ Recursive](./algorithms/cpp/637_Recursive.cpp) | DFS:<br>Traverse the tree using DFS while tracking the current depth. Accumulate the total value and node count for each level. After traversal, divide the total sum by count at each level to compute the averages. | DFS:<br>$O(n)$ | DFS:<br>$O(n)$ |
| 643 | [Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/) | Easy | <b>Sliding Window:</b><br>[C++](./algorithms/cpp/643_SlidingWindow.cpp) | Sliding Window:<br>Use a sliding window of size `k` to compute the sum of each subarray. Update the window sum incrementally and track the maximum. | Sliding Window:<br>$O(n)$ | Sliding Window:<br>$O(1)$ |
| 649 | [Dota2 Senate](https://leetcode.com/problems/dota2-senate/) | Easy | <b>Greedy + Queue Simulation:</b><br>[C++](./algorithms/cpp/649_TwoQueues.cpp) | Greedy + Queue Simulation:<br>Use two queues to simulate the voting process. In each round, the senator with the lower index bans their opponent and is re-added with an index offset by `n`. Repeat until one party's queue is empty. | Greedy + Queue Simulation:<br>$O(n)$ | Greedy + Queue Simulation:<br>$O(n)$ |
| 700 | [Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/) | Easy | <b>BST Search:</b><br>[C++](./algorithms/cpp/700_Recursive.cpp) | BST Search:<br>Use binary search logic on the BST: if the target value is smaller, search the left subtree; if larger, search the right. Return the subtree rooted at the found node, or null if not found. | BST Search:<br>$O(h)$<br>`h` is the height of the tree | BST Search:<br>$O(h)$ |
| 704 | [Binary Search:](https://leetcode.com/problems/binary-search/) | Easy | <b>Binary Search:</b><br>[C++](./algorithms/cpp/704_BinarySearch.cpp) | Binary Search:<br>Use binary search with two pointers (`left` and `right`) to find the target in a sorted array. Narrow the search space by comparing the target with the middle value.  | Binary Search:<br>$O(\log n)$ | Binary Search:<br>$O(1)$ |
| 724 | [Find Pivot Index](https://leetcode.com/problems/find-pivot-index/) | Easy | <b>Prefix Sum:</b><br>[C++](./algorithms/cpp/724_PrefixSum.cpp) | Prefix Sum:<br>Compute the total sum of the array, then iterate while maintaining a running left sum. At each index, check if the left sum equals the right sum (total - current - left). Return the first index where they match. | Prefix Sum:<br>$O(n)$ | Prefix Sum:<br>$O(1)$ |
| 735 | [Asteroid Collision](https://leetcode.com/problems/asteroid-collision/) | Medium | <b>Stack Simulation:</b><br>[Python](./algorithms/py/735_StackSimulation.py) | Stack Simulation:<br>Use a stack to simulate the movement and collision of asteroids. Positive asteroids move right and are pushed onto the stack. Negative ones may collide with the top of the stack. Compare magnitudes to determine which asteroids explode. Continue until all collisions are resolved. | Stack Simulation:<br>$O(n)$ | Stack Simulation:<br>$O(n)$ |
| 746 | [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/) | Easy | <b>Dynamic Programming (Tabulation):</b><br>[C++](./algorithms/cpp/746_Tabulation.cpp) | Dynamic Programming (Tabulation):<br>Use bottom-up DP to calculate the minimum cost to reach each step. For each step, accumulate the minimum of the previous one or two steps. Return the minimum of the last two costs since you can reach the top from either. | Dynamic Programming (Tabulation):<br>$O(n)$ | Dynamic Programming (Tabulation):<br>$O(1)$ |
| 771 | [Jewels and Stones](https://leetcode.com/problems/jewels-and-stones/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/771_Hashing.cpp) | Hashing:<br>Use a hash set to store jewel characters. Then iterate through the stones and count how many are in the set. This enables constant-time lookup for each stone. | Hashing:<br>$O(n + m)$<br>`n` is the length of jewels<br>`m` is the length of stones | Hashing:<br>$O(n)$<br>`n` is the number of unique jewels |
| 804 | [Unique Morse Code Words](https://leetcode.com/problems/unique-morse-code-words/) | Easy | <b>Hashing + Encoding:</b><br>[C++](./algorithms/cpp/804_HashingEncoding.cpp) | Hashing + Enconding:<br>Use an array to map letters to Morse code. For each word, encode it into Morse by concatenating characters' encodings, and insert it into a set to ensure uniqueness. Return the number of unique transformations. | Hashing + Enconding:<br>$O(n \cdot m)$<br>`n` is the number of words<br>`m` is the average word length | Hashing + Enconding:<br>$O(n \cdot m)$ |
| 872 | [Leaf-Similar Trees](https://leetcode.com/problems/leaf-similar-trees/) | Easy | <b>DFS + Leaf Collection:</b><br>[C++ Recursive](./algorithms/cpp/872_Recursive.cpp) | DFS + Leaf Collection:<br>Traverse each tree using DFS to collect the values of the leaf nodes in left-to-right order. Then compare the resulting leaf sequences to determine if the trees are leaf-similar. | DFS + Leaf Collection:<br>$O(n + m)$<br>`n` and `m` are the number of nodes in each tree | DFS + Leaf Collection:<br>$O(n + m)$ |
| 875 | [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) | Medium | [Python](./algorithms/py/875_BinarySearch.py) | Python: Use binary search to find the minimum integer eating speed `k` such that Koko can finish all piles within `h` hours. Do not need to sort `piles` because we're sorting over the values of `k`, not the `piles` values. | Python: $O(n \log m)$, where $n$ is the number of piles and $m$ is the max pile size | Python: $O(1)$ |
| 875 | [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) | Medium | <b>Binary Search:</b><br>[Python](./algorithms/py/875_BinarySearch.py) | Binary Search:<br>Use binary search to find the minimum integer eating speed `k` such that Koko can finish all piles within `h` hours. For each candidate `k`, simulate the total time required. No need to sort the array since we're searching over `k`, not the piles. | Binary Search:<br>$O(n \cdot \log m)$<br>`n` is the number of piles<br>`m` is the max pile size | Binary Search:<br>$O(1)$ |
| 912 | [Sort an Array](https://leetcode.com/problems/sort-an-array/) | Medium | <b>HeapSort:</b><br>[Python Iterative](./algorithms/py/912_HeapsortIterative.py)<br>[Python Recursive](./algorithms/py/912_HeapsortRecursive.py) | HeapSort:<br> Sort the array in-place by first building a max heap. Then, extract the max (root) and place it at the end, reducing the heap size each time. Heapify the new root to maintain the heap property. | Heapsort:<br>$O(n \log n)$| Heapsort:<br>Iterative: $O(1)$<br>Recursive: $O(\log n)$ |
| 938 | [Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/) | Easy | <b>DFS with BST Pruning:</b><br>[C++](./algorithms/cpp/938_Recursive.cpp) | DFS with BST Pruning:<br>Recursively traverse the BST to sum all node values within the range `[low, high]`. Use BST properties to prune: skip left subtree if current value < low, skip right if current value > high. | DFS with BST Pruning:<br>$O(k)$ average case<br>$O(n)$ worst case<br>`k` is the number of nodes visited within range<br>`n` is the number of nodes in the BST | DFS with BST Pruning:<b$O(h)$<br>`h` is the height of the tree |
| 1052 | [Grumpy Bookstore Owner](https://leetcode.com/problems/grumpy-bookstore-owner/) | Medium | <b>Sliding Window:</b><br>[C++](./algorithms/cpp/1052_SlidingWindow.cpp) | Sliding Window:<br>Use sliding window to find the best interval to suppress grumpiness and maximize extra satisfaction. First, calculate base satisfaction when the owner is not grumpy. Then, find the window of size `minutes` that would recover the most unsatisfied customers. Add that to the base for the result. | Sliding Window:<br>$O(n)$n | Sliding Window:<br>$O(1)$ |
| 1108 | [Defanging an IP Address](https://leetcode.com/problems/defanging-an-ip-address/) | Easy | <b>String Manipulation</b><br>[C++](./algorithms/cpp/1108_StringManipulation.cpp) | String Manipulation:<br>Iterate through each character in the string and build a new result. Replace each `'.'` with `"[.]"` and append all other characters as is. | String Manipulation:<br>$O(n)$ | String Manipulation:<br>$O(n)$ |
| 1137 | [N-th Tribonacci Number](https://leetcode.com/problems/n-th-tribonacci-number/) | Easy | <b>Dynamic Programming (Tabulation):</b><br>[C++](./algorithms/cpp/1137_DynamicProgramming.cpp) | Dynamic Programming (Tabulation):<br>Use a rolling array of size 3 to iteratively compute the Tribonacci numbers. Each new value is the sum of the last three. Overwrite values using modular indexing to save space. | Dynamic Programming (Tabulation):<br>$O(n)$ | Dynamic Programming (Tabulation):<br>$O(1)$ |
| 1207 | [Unique Number of Occurrences](https://leetcode.com/problems/unique-number-of-occurrences/) | Easy | <b>Hashing</b><br>[C++](./algorithms/cpp/1207_MapSet.cpp) | Hashing:<br>Use a hash map to count the frequency of each number. Then use a hash set to ensure that all frequency values are unique. Return false if a duplicate frequency is found. | Hashing:<br>$O(n)$ | Hashing:<br>$O(n)$ |
| 1302 | [Deepest Leaves Sum](https://leetcode.com/problems/deepest-leaves-sum/) | Easy | <b>DFS:</b><br>[C++ Recursive](./algorithms/cpp/1302_Recursive.cpp) | DFS:<br>Traverse the tree to track the maximum depth and sum of leaf nodes at that depth. Update the sum only when reaching leaves at the deepest level. | DFS:<br> $O(n)$ | DFS:<br> $O(h)$<br>`h` is the height of the tree |
| 1370 | [Increasing Decreasing String](https://leetcode.com/problems/increasing-decreasing-string/) | Easy | <b>Greedy:</b><br>[C++](./algorithms/cpp/1370_Greedy.cpp) | Greedy:<br>Reconstruct the output by repeatedly choosing the smallest then largest remaining characters, ensuring each is picked only once per pass. Alternate directions until all characters are used. | Greedy:<br>$O(n)$ | Greedy:<br>$O(1)$ |
| 1431 | [Kids With the Greatest Number of Candies](https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/) | Easy | <b>Greedy:</b><br>[C++](./algorithms/cpp/1431_Greedy.cpp) | Greedy:<br>Find the current maximum number of candies. For each kid, check if giving them all the extra candies makes them at least tie with the max. Return the result as a boolean array. | Greedy:<br>$O(n)$ | Greedy:<br>$O(1)$ |
| 1456 | [Maximum Number of Vowels in a Substring of Given Length](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/) | Medium | <b>Sliding Window:</b><br>[C++ with Set](./algorithms/cpp/1456_SetSlidingWindow.cpp)<br>[C++ with Conditionals](./algorithms/cpp/1456_ConditionalSlidingWindow.cpp) | Sliding Window:<br>Use a sliding window of length `k` to track the number of vowels in the current substring. As the window moves forward, adjust the count by checking only the entering and exiting characters. |  Sliding Window:<br>$O(n)$ |  Sliding Window:<br>$O(1)$ |
| 1470 | [Shuffle the Array](https://leetcode.com/problems/shuffle-the-array/) | Easy | <b>Two Pointers:</b><br>[C++](./algorithms/cpp/1470_TwoPointers.cpp) | Two Pointers:<br>Iterate through both halves of the array simultaneously using index offsets. Push one element from each half alternately into the result to build the shuffled array. | Two Pointers:<br>$O(n)$ | Two Pointers:<br>$O(n)$ |
| 1512 | [Number of Good Pairs](https://leetcode.com/problems/number-of-good-pairs/) | Easy | <b>Hashing:</b><br>[C++ One-Pass](./algorithms/cpp/1512_MapSingleLoop.cpp)<br>[C++ Two-Pass](./algorithms/cpp/1512_MapTwoLoops.cpp) | Hashing:<br>Use a hash map to count the frequency of each number. One version counts pairs during map construction by adding `count - 1` for each occurrence. The other builds the map first and then uses $\binom{n}{2}$ to calculate the number of good pairs for each value. | $O(n)$ | $O(k)$<br>`k` is the number of distinct elements |
| 1598 | [Crawler Log Folder](https://leetcode.com/problems/crawler-log-folder/) | Easy | <b>Stack Simulation:</b><br>[C++](./algorithms/cpp/1598_StackSimulation.cpp) | Stack Simulation:<br>Simulate folder traversal using a counter for depth. Increment for `"x/"`, decrement for `"../"` (but not below 0), and ignore `"./"`. The result is the number of steps needed to return to the main folder. | Stack Simulation:<br>$O(n)$ | Stack Simulation:<br>$O(1)$ |
| 1614 | [Maximum Nesting Depth of the Parentheses](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/) | Easy | <b>Stack Simulation:</b><br>[C++](./algorithms/cpp/1614_StackSimulation.cpp) | Stack Simulation:<br>Iterate through the string, increasing a depth counter for `'('` and decreasing for `')'`. Track the maximum value of the counter to determine the deepest level of nesting. | Stack Simulation:<br>$O(n)$ | Stack Simulation:<br>$O(1)$ |
| 1672 | [Richest Customer Wealth](https://leetcode.com/problems/richest-customer-wealth/) | Easy | <b>Simulation:</b><br>[C++](./algorithms/cpp/1672_Simulation.cpp) | Simulation:<br>For each customer (row), compute the sum of their bank balances and track the maximum across all customers. | Simulation:<br>$O(m \cdot n)$ | Simulation:<br>$O(1)$ |
| 1684 | [Count of Number of Consistent Strings](https://leetcode.com/problems/count-the-number-of-consistent-strings/) | Easy    | [C++](./algorithms/cpp/1684_Hashing.cpp) | C++: Build a boolean array to keep track of which of the 26 English letters are allowed. Loop through the words and if there exists a disallowed letter, decrement the counter. |C++: $O(n^2)$|C++: $O(1)$|
| 1684 | [Count the Number of Consistent Strings](https://leetcode.com/problems/count-the-number-of-consistent-strings/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/1684_Hashing.cpp) | Hashing:<br>Use a fixed-size boolean array to record which letters are allowed. For each word, check that all its characters are marked as allowed. Count the number of fully consistent words. | Hashing:<br>$O(n \cdot m)$<br>`n` is the number of words<br>`m` is the average word length | Hashing:<br>$O(1)$ |
| 1732 | [Find the Highest Altitude](https://leetcode.com/problems/find-the-highest-altitude/) | Easy | <b>Prefix Sum:</b><br>[C++](./algorithms/cpp/1732_PrefixSum.cpp) | Prefix Sum:<br>Iterate through the `gain` array while computing the running sum (altitude) and tracking the maximum altitude seen so far. | Prefix Sum:<br>$O(n)$ | Prefix Sum:<br>$O(1)$ |
| 1742 | [Maximum Number of Balls in a Box](https://leetcode.com/problems/maximum-number-of-balls-in-a-box/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/1742_Hashing.cpp) | Hashing:<br>Map each ball to a box using the sum of its digits as the hash key. Count how many balls fall into each box using a fixed-size array, and return the maximum frequency. | $O(n \cdot d)$<br>`d` is number of digits per number (at most 6) | $O(1)$ |
| 1748 | [Sum of Unique Elements](https://leetcode.com/problems/sum-of-unique-elements/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/1748_Map.cpp) | Hashing:<br>Use a hash map to count the frequency of each number in the array, then sum the numbers that appear exactly once. | Hashing:<br>$O(n)$ | Hashing:<br>$O(n)$ |
| 1752 | [Check if Array Is Sorted and Rotated](https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/) | Easy | <b>Greedy:</b><br>[Python](./algorithms/py/1752_Greedy.py) | Greedy:<br>Iterate through the array and count how many times the current element is greater than the next (modulo for circularity). The array is valid if there's at most one such inversion. |  Greedy:<br>$O(n)$ |  Greedy:<br>$O(1)$ |
| 1768 | [Merge Strings Alternately](https://leetcode.com/problems/merge-strings-alternately/) | Easy | <b>Two Pointers:</b><br>[C++](./algorithms/cpp/1768_OnePointer.cpp) | Two Pointers:<br>Iterate through both strings, appending one character from each at a time. Once one string ends, append the remaining characters of the longer string. | Two Pointers:<br>$O(n)$ | Two Pointers:<br>$O(1)$ |
| 1832 | [Check if the Sentence Is Pangram](https://leetcode.com/problems/check-if-the-sentence-is-pangram/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/1832_Array.cpp) | Hashing:<br>Track seen characters using a fixed-size boolean array of 26 elements. Count the number of unique letters seen, and return true once all 26 letters are present. | Hashing:<br>$O(n)$ | Hashing:<br>$O(1)$ |
| 1920 | [Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/) | Easy | <b>Simulation:</b><br>[C++](./algorithms/cpp/1920_Simulation.cpp) | Simulation:<br>Construct a new array where each element at index `i` is assigned `nums[nums[i]]` by directly evaluating the permutation rule. | Simulation:<br>$O(n)$ | Simulation:<br>$O(n)$ |
| 1926 | [Nearest Exit from Entrance in Maze](https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/) | Medium | <b>BFS:</b><br>[Python Iterative](./algorithms/py/1926_BFSIterative.py) | BFS:<br>Use breadth-first search from the entrance to explore the maze level by level. Track steps and return the first time you reach a border cell that is not the entrance. | BFS:<br>$O(m \cdot n)$<br>`m` is the number of rows<br>`n` is the number of columns| BFS:<br>$O(m \cdot n)$ |
| 1929 | [Concatenation of Array](https://leetcode.com/problems/concatenation-of-arry/) | Easy | <b>Simulation:</b><br>[C++](./algorithms/cpp/1929_Iterative.cpp) | Simulation:<br>Build the result array by looping twice over the original `nums` and appending each element. Use modulo to wrap the index. | Simulation:<br>$O(n)$ | Simulation:<br>$O(n)$ |
| 2037 | [Minimum Number of Moves to Seat Everyone](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/) | Easy | <b>Greedy:</b><br>[C++](./algorithms/cpp/2037_Sorting.cpp) | Greedy:<br>Sort both `seats` and `students`. Pair each student to the corresponding seat by index and sum the absolute position differences to compute the minimum total moves. | Greedy:<br>$O(n \log n)$ | Greedy:<br>$O(1)$ |
| 2108 | [Find First Palindromic String in the Array](https://leetcode.com/problems/find-first-palindromic-string-in-the-array/) | Easy | <b>Two Pointers:</b><br>[C++](./algorithms/cpp/2108_TwoPointers.cpp) | Two Pointers:<br>For each word, use two pointers to check if it reads the same forward and backward. Return the first such palindromic word found. | Two Pointers:<br>$O(n \cdot m)$<br>`n` is the number of words<br>`m` is the average word length | Two Pointers:<br>$O(1)$ |
| 2131 | [Longest Palindrome by Concatenating Two Letter Words](https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/) | Medium | <b>Hashing:</b><br>[Python](./algorithms/py/2131_Hashing.py) | Hashing:<br>Use a frequency map to count occurrences of each word. Match each asymmetric word with its reverse. For symmetric words, use pairs and allow one to be the center of the palindrome if an odd count remains. | Hashing:<br>$O(n)$ | Hashing:<br>$O(n)$ |
| 2149 | [Rearrange Array Elements by Sign](https://leetcode.com/problems/rearrange-array-elements-by-sign/) | Medium | <b>Two Pointers:</b><br>[C++](./algorithms/cpp/2149_TwoPointers.cpp) | Two Pointers:<br>Use two pointers to place positive numbers at even indices and negative numbers at odd indices. Iterate once through the array and assign each number to its correct position. | Two Pointers:<br>$O(n)$ | Two Pointers:<br>$O(n)$ |
| 2215 | [Find the Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/2215_Hashing.cpp) | Hashing:<br>Use hash sets to remove duplicates and enable constant-time lookup. Check which elements in each set are not present in the other to build the result. | Hashing:<br>$O(n + m)$<br>`n` is the size of `nums1`<br> `m` is the size of `nums2` | Hashing:<br>$O(n + m)$ |
| 2300 | [Successful Pairs of Spells and Potions](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/) | Medium | <b>Binary Search:</b><br>[C++](./algorithms/cpp/2300_BinarySearch.cpp) | Binary Search:<br>Sort the `potions` array. For each spell, compute the minimum required potion strength and use binary search to count how many potions meet or exceed that value. | Binary Search:<br>$O(m \log m + n \log m)$<br>`n` is the number of spells<br>`m` is the number of potions | Binary Search:<br>$O(1)$ |
| 2325 | [Decode the Message](https://leetcode.com/problems/decode-the-message/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/2325_Hashing.cpp) | Hashing:<br>Construct a substitution map based on the first occurrence of each letter in the key. Then decode the message by replacing each letter using this map. | Hashing:<br>$O(m + k)$<br>`m` is the message length<br>`k` is the key length | Hashing:<br>$O(1)$<br>|
| 2351 | [First Letter to Appear Twice](https://leetcode.com/problems/first-letter-to-appear-twice/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/2351_Set.cpp) | Hashing:<br>Use a hash set to track seen letters. Return the first character whose second appearance is encountered during iteration. | Hashing:<br>$O(n)$ | Hashing:<br>$O(1)$<br> |
| 2384 | [Largest Palindromic Number](https://leetcode.com/problems/largest-palindromic-number/) | Medium | <b>Greedy:</b><br>[C++](./algorithms/cpp/2384_Greedy.cpp) | Greedy:<br>Count the frequency of each digit. Greedily build the left half of the palindrome with the largest digits first, place the largest available odd-count digit in the center (if any), then mirror the left half to form the right. | Greedy:<br>$O(n)$ | Greedy:<br>$O(1)$<br> |
| 2390 | [Removing Stars From a String](https://leetcode.com/problems/removing-stars-from-a-string/) | Medium | <b>Stack Simulation:</b><br>[Python](./algorithms/py/2390_StackSimulation.py) | Stack Simulation:<br>Iterate through the string. Push characters onto a stack until a `*` is encountered, then pop the last character. Join the stack at the end to return the resulting string. | Stack Simulation:<br>$O(n)$ | Stack Simulation:<br>$O(n)$ |
| 2413 | [Smallest Even Multiple](https://leetcode.com/problems/smallest-even-multiple/) | Easy | <b>Math:</b><br>[C++](./algorithms/cpp/2413_Math.cpp) | Math:<br>Return `n` if it's already even; otherwise return `2 * n` to make it the smallest even multiple. | Math:<br>$O(1)$ | Math:<br>$O(1)$ |
| 2460 | [Apply Operations to an Array](https://leetcode.com/problems/apply-operations-to-an-array/) | Easy | <b>Two Pointers:</b><br>[Python](./algorithms/py/2460_TwoPointers.py) | Two Pointers:<br>First pass merges equal adjacent values. Second pass uses two pointers to shift non-zero elements forward, then fills the remainder with zeroes. | Two Pointers:<br>$O(n)$ | Two Pointers:<br>$O(1)$ |
| 2469 | [Convert the Temperature](https://leetcode.com/problems/convert-the-temperature/) | Easy | <b>Math:</b><br>[C++](./algorithms/cpp/2469_Math.cpp) | Math:<br>Apply fixed conversion formulas:<br> Kelvin = Celsius + 273.15<br> Fahrenheit = Celsius × 1.80 + 32.00. <br>Return the result as a two-element array. | Math:<br>$O(1)$ | Math:<br>$O(1)$ |
| 2716 | [Minimize String Length](https://leetcode.com/problems/first-letter-to-appear-twice/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/2716_Hashing.cpp) | Hashing:<br>Use a fixed-size boolean array to track distinct characters. The minimum possible length is equal to the number of unique characters in the string. | Hashing:<br>$O(n)$ | Hashing:<br>$O(1)$<br>|
| 2769 | [Find the Maximum Achievable Number](https://leetcode.com/problems/find-the-maximum-achievable-number/) | Easy | <b>Math:</b><br>[C++](./algorithms/cpp/2769_Math.cpp) | Math:<br>Each operation increases the total difference between the two numbers by 2. The maximum achievable value is `num + 2 * t`. | Math:<br>$O(1)$ | Math:<br>$O(1)$ |
| 2798 | [Number of Employees Who Met the Target](https://leetcode.com/problems/number-of-employees-who-met-the-target/) | Easy | <b>Simulation:</b><br>[C++](./algorithms/cpp/2798_Simulation.cpp) | Simulation:<br>Traverse the array and count how many employees have hours greater than or equal to the target. | Simulation:<br>$O(n)$ | Simulation:<br>$O(1)$ |
| 2842 | [Count Pairs Whose Sum is Less than Target](https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/) | Easy | <b>Brute Force:</b><br>[C++](./algorithms/cpp/2842_BruteForce.cpp) | Brute Force:<br>Use two nested loops to check all possible pairs `(i, j)` where `i < j`, and count how many pairs have a sum less than the target. | Brute Force:<br>$O(n^2)$ | Brute Force:<br>$O(1)$ |
| 2903 | [Find Indices With Index and Value Difference I](https://leetcode.com/problems/find-indices-with-index-and-value-difference-i/) | Easy | <b>Brute Force:</b><br>[C++](./algorithms/cpp/2903_BruteForce.cpp) | Brute Force:<br>Iterate through all pairs `(i, j)` and return the first pair that satisfies both the index and value difference constraints. | Brute Force:<br>$O(n^2)$ | Brute Force:<br>$O(1)$ |
| 2942 | [Find Words Containing Character](https://leetcode.com/problems/find-words-containing-character/) | Easy | <b>Brute Force:</b><br>[C++](./algorithms/cpp/2942_BruteForce.cpp) | Brute Force:<br>For each word, check each character until the target character is found. Record the index of the word and break to avoid unnecessary scans. | Brute Force:$O(n \cdot m)$<br>`n` is the number of words<br> `m` is the average word length | Brute Force:$O(n)$<br> |
| 3024 | [Type of Triangle](https://leetcode.com/problems/type-of-triangle/) | Easy | <b>Math:</b><br>[Python](./algorithms/py/3024_Math.py) | Math:<br>Sort the three sides and check the triangle inequality. Then use equality checks to classify the triangle as equilateral, isosceles, or scalene. Return "none" if it doesn’t satisfy the inequality. | Math:<br>$O(1)$ | Math:<br>$O(1)$ |
| 3110 | [Score of a String](https://leetcode.com/problems/score-of-a-string/) | Easy | <b>Math:</b><br>[C++](./algorithms/cpp/3110_Math.cpp) | Math:<br>Iterate through the string and accumulate the absolute differences between ASCII values of consecutive characters. |Math:<br> $O(n)$ | Math:<br>$O(1)$ |
| 3121 | [Count the Number of Special Characters II](https://leetcode.com/problems/count-the-number-of-special-characters-ii/) | Medium | <b>Hashing:</b><br>[C++](./algorithms/cpp/3121_Array.cpp) | Hashing:<br>Use two fixed-size arrays to track lowercase and uppercase presence of each letter. A letter is special if all lowercase appearances precede the first uppercase one. | Hashing:<br>$O(n)$ | Hashing:<br>$O(1)$<br>|
| 3146 | [Permutation Difference between Two Strings](https://leetcode.com/problems/permutation-difference-between-two-strings/) | Easy | <b>Hashing:</b><br>[C++](./algorithms/cpp/3146_Hashing.cpp) | Hashing:<br>Use a hash map to store each character’s index in string `s`. Then iterate through `t` and accumulate the absolute index differences. | Hashing:<br>$O(n)$ | Hashing:<br>$O(n)$ |
| 3151 | [Special Array I](https://leetcode.com/problems/special-array/) | Easy | <b>Greedy:</b><br>[Python](./algorithms/py/3151_Greedy.py) | Greedy:<br>Check each adjacent pair for alternating parity using bitwise AND. Return False immediately if two consecutive numbers have the same parity. | Greedy:<br>$O(n)$ | Greedy:<br>$O(1)$ |
| 3162 | [Find the Number of Good Pairs I](https://leetcode.com/problems/find-the-number-of-good-pairs-i/) | Easy | <b>Brute Force:</b><br>[C++](./algorithms/cpp/3162_BruteForce.cpp) | Brute Force:<br>Multiply each element in `nums2` by `k`, then iterate over all pairs `(i, j)` and count those where `nums1[i]` is divisible by `nums2[j]`. | Brute Force:<br>$O(n^2)$ | Brute Force:<br>$O(1)$ |
| 3190 | [Find Minimum Operations to Make All Elements Divisible by Three](https://leetcode.com/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/) | Easy | <b>Math:</b><br>[C++](./algorithms/cpp/3190_Math.cpp) | Math:<br>Iterate through the array and count how many elements are not divisible by 3. Each such element requires exactly one operation to become divisible. | Math:<br>$O(n)$ | Math:<br>$O(1)$ |
| 3355 | [Zero Array Transformation I](https://leetcode.com/problems/zero-array-transformation-i/) | Medium | <b>Prefix Sum:</b><br>[C++](./algorithms/cpp/3355.PrefixSum.cpp)<br>[Python](./algorithms/py/3355_PrefixSum.py) | Prefix Sum:<br>Use a difference array to track range decrements efficiently. Then apply a prefix sum to compute the cumulative decrements at each index. If any index requires more decrements than allowed, return false. | Prefix Sum:<br>$O(n + m)$<br>`n` is the length of `nums`<br>`m` is the number of queries | Prefix Sum:<br>$O(n)$ |
