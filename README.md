Author: Cuong Phan
### LeetCode Journal

| No. | Name    | Difficulty | Solution              |Notes|Time Complexity|Space Complexity|
| --- | ------- | ---------- | --------------------- |----|---|-|
| 1  | [Two Sum](https://leetcode.com/problems/two-sum/) | Easy       | [C#](./algorithms/cs/1_HashMap.cs) | C#: Use a hashmap to look up values at constant time.|C#: $O(n)$|C#: $O(n)$|
| 2  | [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) | Medium       | [C#](./algorithms/cs/2_LinkedLists.cs) | C#: Remember to check if the last addition requires a carry node|C#: $O(max(m, n))$|C#: $O(max(m, n))$|
| 3  | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | Medium       | [C#](./algorithms/cs/3_SlidingWindow.cs) | C#: Use a hashmap to to store the last visited index of a character.|C#: $O(n)$|C#: $O(min(m, n))$|
| 4  | [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/) | Hard      | [C#_Iterative](./algorithms/cs/4_Iterative.cs) | C# Iterative: Use two pointers to traverse the arrays until you encounter the medians.|C# Iterative: $O(m + n)$|C# Iterative: $O(1)$|
| 5  | [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) | Medium     | [C#](./algorithms/cs/5_CenterExpansion.cs) | C#: Use two pointers 'left' and 'right' of the substring with the ith element as its center and keep expanding by the sides as long as the string is palindromic. Remember to check the both odd and even lengths.|C#: $O(n^{2})$|C#: $O(1)$|
| 6  | [Zigzag Conversion](https://leetcode.com/problems/zigzag-conversion/) | Medium    | [C#](./algorithms/cs/6_Iterative.cs) | C#: Create an array of StringBuilder corresponding to the rows, iteratively append the characters into the StringBuilder array.|C#: $O(n)$|C#: $O(n)$|
| 7  | [Reverse Integer](https://leetcode.com/problems/reverse-integer/) | Medium    | [C#](./algorithms/cs/7_Iterative.cs) | C#: Check if underflows or overflows before adding the tail end digit to the result int iteratively using modulus.|C#: $O(log(n))$|C#: $O(1)$|
| 8  | [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/) | Medium    | [C#](./algorithms/cs/8_Iterative.cs) | C#: Skip leading whitespaces, check for sign, subtract ASCII '0' to get value, check if underflows or overflows. |C#: $O(n)$|C#: $O(1)$|
| 9  | [Palindrome Number](https://leetcode.com/problems/palindrome-number/) | Medium    | [C#](./algorithms/cs/9_MidReverse.cs) | C#: False if negative or divisible by 10 (excluding 0), reverse till middle, check if reversed = original (odd-length number) or reversed / 10 = original (even-length number). |C#: $O(log(n))$|C#: $O(1)$|
| 11  | [Container With Most Water](https://leetcode.com/problems/container-with-most-water/) | Medium    | [C#](./algorithms/cs/11_TwoPointers.cs)<br><br>[C++](./algorithms/cpp/11_TwoPointers.cpp) | C#: Use two pointers at the start and end of array, contract the container by the lower wall's side.<br><br>C++: Use two pointers at the start and end of array, contract the container by the lower wall's side. |C#: $O(n)$<br><br>C++: $O(n)$|C#: $O(1)$<br><br>C++: $O(1)$|
| 13  | [Roman to Integer](https://leetcode.com/problems/roman-to-integer/) | Easy    | [C++](./algorithms/cpp/13_Iterative.cpp) | C++: If the next numeral is larger then subtract the current one, else add it. |C++: $O(n)$|C++: $O(1)$|
| 15  | [3Sum](https://leetcode.com/problems/3sum/) | Medium    | [C++](./algorithms/cpp/15_TwoPointers.cpp) | C++: Sort the array, iterate through the array as "fixed value" then use two pointers on the subarray on the right to find the triplets. |C++: $O(n^2)$|C++: $O(1)$|
| 16  | [3Sum Closest](https://leetcode.com/problems/3sum-closest/) | Medium    | [C++](./algorithms/cpp/16_TwoPointers.cpp) | C++: Sort the array, iterate through the array as "fixed value" then use two pointers on the subarray on the right to find the triplet. |C++: $O(n^2)$|C++: $O(1)$|
| 17  | [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) | Medium    | [C++](./algorithms/cpp/17_Recursive.cpp) | C++: Use a recursive backtrack method. Base case if when the currentString is the same length as digits |C++: $O(3^N*4^M)$, N is the number of digits in the input string that map to 3 letters and M is the number of digits that map to 4 letters.|C++: $O(3^N*4^M)$|
| 20  | [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) | Easy    | [C++_StackMap](./algorithms/cpp/20_StackMap.cpp)<br><br>[C++_StackNoMap](./algorithms/cpp/20_StackNoMap.cpp) | C++_StackMap: Use a stack to keep track of the latest added opening parenthesis and a map to map opening parentheses to their closing counterparts.<br><br>C++_StackNoMap: Using conditions instead of a map may improve speed and lower space because there are only three parenthesis types in exchange for readability and scalability. |C++_StackMap: $O(N)$.<br><br>C++_StackNoMap: $O(N)$.|C++_StackMap $O(N)$<br><br>C++_StackNoMap: $O(N)$.|
| 22  | [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) | Medium    | [C++](./algorithms/cpp/22_Recursion.cpp) | C++: Use recursion and 2 integers to keep track of how many opening and closing parentheses there are in the strings. |C++: $O(2^N)$.|C++: $O(N)$|
| 27  | [Remove Element](https://leetcode.com/problems/remove-element/) | Easy    | [C++](./algorithms/cpp/27_TwoPointers.cpp) | C++: Use two pointers to find target values in the left and non-target values in the right to swap. |C++: $O(N)$.|C++: $O(1)$|
| 28  | [Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/) | Easy    | [C++](./algorithms/cpp/28_Iterative.cpp) | C++_Iterative: Use an iterative approach (you can use substr instead of another loop but it is less memory-efficient). |C++_Iterative: $O(N * M)$.|C++: $O(1)$|
| 35  | [Search Insert Position](https://leetcode.com/problems/search-insert-position/) | Easy    | [C++](./algorithms/cpp/35_BinarySearch.cpp) | C++: Binary search approach, remember to update the left and right pointers PAST the middle pointer. |C++: $O(log(n))$|C++: $O(1)$|
| 38  | [Count and Say](https://leetcode.com/problems/count-and-say/) | Medium    | [C++](./algorithms/cpp/38_Iterative.cpp) | C++: Iterative approach|C++: $O(n)$|C++: $O(2^n)$|
| 39  | [Combination Sum](https://leetcode.com/problems/combination-sum/) | Medium    | [C++](./algorithms/cpp/39_Backtrack.cpp) | C++: Recursive backtrack approach (remember to run j from i to avoid duplicate result as well as pass by reference to increase performance). |C++: $O(2^n)$|C++: $O(2^n)$|
| 55  | [Jump Game](https://leetcode.com/problems/jump-game/) | Medium    | [C++](./algorithms/cpp/55_Greedy.cpp) | C++: Use greedy algorithm, iterate through the vector, if current index is larger than max reach then return false else update max reach. |C++: $O(n)$|C++: $O(1)$|
| 58  | [Length of Last Word](https://leetcode.com/problems/length-of-last-word/) | Easy    | [C++](./algorithms/cpp/58_Iterative.cpp) | C++: Iterative approach, iterate from the back with 2 while loops (not nested). |C++: $O(n)$|C++: $O(1)$|
| 66  | [Plus One](https://leetcode.com/problems/plus-one/) | Easy    | [C++](./algorithms/cpp/66_Iterative.cpp) | C++: Don't try to add too many conditions in the loop. |C++: $O(n)$|C++: $O(1)$|
| 75  | [Sort Colors](https://leetcode.com/problems/sort-colors/) | Medium    | [C++](./algorithms/cpp/75_ThreePointers.cpp) | C++: Use the Dutch National Flag (3-way partition algorithm). |C++: $O(n)$|C++: $O(1)$|
| 100  | [Same Tree](https://leetcode.com/problems/same-tree/) | Easy    | [C++](./algorithms/cpp/100_Recursive.cpp) | C++: Use recursive depth-first traversal of the tree to see if each node pair is the same. |C++: $O(n)$|C++: $O(h) with h being the height of the tree.$|
| 101  | [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/) | Easy    | [C++](./algorithms/cpp/101_Recursive.cpp) | C++: Use recursive depth-first traversal of the tree to see if each node pair is the same. |C++: $O(n)$|C++: $O(h) with h being the height of the tree.$|
| 104  | [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | Easy    | [C++](./algorithms/cpp/104_Recursive.cpp) | C++: Use recursive depth-first traversal of the tree (check if the currentNode is nullptr before incrementing the count). |C++: $O(n)$|C++: $O(h) with h being the height of the tree.$|
| 111  | [Minimum Depth of Binary Tree](https://leetcode.com/problems/path-sum/) | Easy    | [C++](./algorithms/cpp/111_Recursive.cpp) | C++: Use recursive depth-first traversal of the tree. |C++: $O(n)$|C++: $O(h) with h being the height of the tree.$|
| 112  | [Path Sum](https://leetcode.com/problems/path-sum/) | Easy    | [C++](./algorithms/cpp/112_Recursive.cpp) | C++: Use recursive depth-first traversal of the tree. |C++: $O(n)$|C++: $O(h) with h being the height of the tree.$|
| 118  | [Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/) | Easy    | [C++](./algorithms/cpp/118_Combinatorial.cpp) | C++: Initialize each row with values of 1, adjust the middle values with combinatorial formula. |C++: $O(n^2)$|C++: $O(n^2)$|
| 119  | [Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/) | Easy    | [C++_TwoRows](./algorithms/cpp/119_TwoRows.cpp)<br><br>[C++_OneRow](./algorithms/cpp/119_OneRow.cpp) | C++_TwoRows: Make base rows - vector<int> prevRow(1, 1) and use two vectors to store the current row and the previous row for calculation. <br><br>C++_OneRow: Use a single row with size rowIndex + 1, calculate the middle values backwards (row[j] += row[j - 1]).|C++_TwoRows: $O(n^2)$<br><br>C++_OneRow: $O(n^2)|C++_TwoRows: $O(n)$<br><br>C++_OneRow: $O(n)$|
| 121  | [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) | Easy    | [C++](./algorithms/cpp/121_Iterative.cpp) | C++: Update minBuy and maxProfit separately. |C++: $O(n)$|C++: $O(1)$|
| 122  | [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) | Medium    | [C++](./algorithms/cpp/122_Iterative.cpp) | C++: If price is lower, update minBuy if not sell constantly. |C++: $O(n)$|C++: $O(1)$|
| 125  | [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) | Easy    | [C++](./algorithms/cpp/125_TwoPointers.cpp) | C++: Two pointers. |C++: $O(n)$|C++: $O(1)$|
| 136  | [Single Number](https://leetcode.com/problems/single-number/) | Easy    | [C++](./algorithms/cpp/136_XOR.cpp) | C++: XOR each element of the array (if an element appears twice, XOR would be 0 which means XOR product of the entire array is the element that only appears once) and order and position do not matter in XOR. |C++: $O(n)$|C++: $O(1)$|
| 141  | [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) | Easy    | [C++](./algorithms/cpp/141_FloydsCycleDetection.cpp) | C++: Use Floyd's Cycle Detection, have 2 pointers called slow and fast, slow iterate through each node, fast skips a node. If the fast pointer exits the list, no cycle if the fast and slow pointers meet, there is a cycle. |C++: $O(n)$|C++: $O(1)$|
| 144  | [Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/) | Easy    | [C++](./algorithms/cpp/144_Recursive.cpp) | C++: Use recursive approach. |C++: $O(n)$|C++: $O(h)$|
| 145  | [Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/) | Easy    | [C++](./algorithms/cpp/145_Recursive.cpp) | C++: Use recursive approach. |C++: $O(n)$|C++: $O(h)$|
| 167  | [Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) | Medium    | [C++](./algorithms/cpp/167_TwoPointers.cpp) | C++: Use two pointers and increment or decrement them so that the sum creep towards the target. |C++: $O(n)$|C++: $O(1)$|
| 202  | [Happy Number](https://leetcode.com/problems/happy-number/) | Easy    | [C++_UnorderedSet](./algorithms/cpp/202_UnorderedSet.cpp) | C++_UnorderedSet: Use unordered set to keep track of what sum has been seen to detect cycle.|C++_UnorderedSet: $O(log(n))$ |C++_UnorderedSet: $O(log(n))$|
| 217  | [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) | Easy    | [C++_Set](./algorithms/cpp/217_Set.cpp)<br><br>[C++_Sorting](./algorithms/cpp/217_Sorting.cpp) | C++_Set: Use a set to keep track of which number has been tracked.<br><br>Sort the nums array, iterate through the array and check if the current value is the same as the next value.|C++_Set: $O(n)$<br><br> C++_Sorting: $O(n*log(n))$|C++_Set: $O(n)$<br><br>C++_Sorting: $O(1)$|
| 219  | [Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/) | Easy    | [C++_Map](./algorithms/cpp/219_Map.cpp) | C++: Use a map to store the most recent index of the current value (besides the current index). Check if the condition is met, if not update the most recent index to the current index.|C++: $O(n)$ |C++: $O(n)$|
| 222  | [Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/) | Easy    | [C++](./algorithms/cpp/222_Recursive.cpp) | C++: Use a recursive approach. |C++: $O(n)$ |C++: $O(h)$ |
| 225  | [Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/) | Easy    | [C++](./algorithms/cpp/225_OneQueue.cpp) | C++: Use one queue. |C++: N/A |C++: N/A |
| 228  | [Summary Ranges](https://leetcode.com/problems/summary-ranges/) | Easy    | [C++](./algorithms/cpp/228_Iterative.cpp) | C++: Use iterative approach. |C++: $O(n)$ |C++: $O(1)$ |
| 232  | [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/) | Easy    | [C++](./algorithms/cpp/232_TwoStacks.cpp) | C++: Use two stacks. |C++: N/A |C++: N/A |
| 242  | [Valid Anagram](https://leetcode.com/problems/valid-anagram/) | Easy    | [C++_Sorting](./algorithms/cpp/242_Sorting.cpp)<br><br>[C++_Map](./algorithms/cpp/242_Map.cpp)<br><br>[C++_MapArray](./algorithms/cpp/242_MapArray.cpp) | C++_Sorting: Sort the two strings then compare.<br><br>C++_Map: Use a map to store the frequencies of the characters, increment if appears in string s, decrement if appears in string t. Return true if all characters have frequency of 0.<br><br>C++_MapArray: Same logic but we can use an array with 26 elements for 26 characters in the alphabet (would not work for the follow-up question). |C++_Sorting: $O(nlog(n))$<br><br>C++_Map: $O(n)$<br><br>C++_MapArray: $O(n)$ |C++_Sorting: $O(1)$<br><br>C++_Map:$O(n)$<br><br>C++_Map:$O(1)  |
| 263  | [Ugly Number](https://leetcode.com/problems/ugly-number/) | Easy    | [C++](./algorithms/cpp/263_Recursive.cpp) | C++: Use a recursive approach.|C++: N/A |C++: N/A|
| 268  | [Missing Number](https://leetcode.com/problems/missing-number/) | Easy    | [C++](./algorithms/cpp/268_Vector.cpp) | C++: Use a boolean vector to keep track of which number is present. |C++: $O(n)$ |C++: $O(n)$|
| 278  | [First Bad Version](https://leetcode.com/problems/first-bad-version/) | Easy    | [C++_TwoPointers](./algorithms/cpp/278_TwoPointers.cpp) | C++: Use two pointers approach.|C++: $O(log(n))$ |C++: $O(1)$|
| 283  | [Move Zeroes](https://leetcode.com/problems/move-zeroes/) | Easy    | [C++_Swap](./algorithms/cpp/283_Swap.cpp) | C++_Swap: Iterate through the list, use a pointer to keep track of where the last non-zero element ahead of the current element to swap if the current element is 0.|C++_Swap: $O(n)$ |C++_Swap: $O(1)$|
| 290  | [Word Pattern](https://leetcode.com/problems/word-pattern/) | Easy    | [C++_Maps](./algorithms/cpp/290_Maps.cpp) | C++_Maps: Use 2 maps strToPat and patToStr to check for bijection. |C++_Maps: $O(n)$ |C++_Maps: $O(n)$|
| 338  | [Counting Bits](https://leetcode.com/problems/counting-bits/) | Easy    | [C++](./algorithms/cpp/338_Tabulation.cpp) | C++: Bottom-up DP approach. |C++: $O(n)$|C++: $O(1)$|
| 345  | [Reverse Vowels of a String](https://leetcode.com/problems/reverse-vowels-of-a-string/) | Easy    | [C++](./algorithms/cpp/345_TwoPointers.cpp) | C++: Two pointers approach. |C++: $O(n)$|C++: $O(1)$|
| 374  | [Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/) | Easy    | [C++](./algorithms/cpp/374_BinarySearch.cpp) | C++: Binary search approach. |C++: $O(log(n))$|C++: $O(1)$|
| 383  | [Ransom Note](https://leetcode.com/problems/ransom-note/) | Easy    | [C++](./algorithms/cpp/383_UnorderedMap.cpp) | C++: Build a map from the magazine then iterate and decrement map value by character's appearance in the ransom note. |C++: $O(m + n)$|C++: $O(m)$|
| 389  | [Find the Difference](https://leetcode.com/problems/find-the-difference/) | Easy    | [C++_Sorting](./algorithms/cpp/389_Sorting.cpp)<br><br>[C++_Map](./algorithms/cpp/389_Map.cpp) | C++_Sorting: Sort both strings then compare to find the difference iteratively.<br><br>C++_Map: Build a frequency map of the string s then retract the occurences of characters in string t, whichever character has a negative frequency is the difference. |C++_Sorting: $O(n*log(n))$<br><br>C++_Map: $O(n)$|C++_Sorting: $O(m)$<br><br>C++_Map: $O(1)$ because at most, it'll store 26 characters|
| 392  | [Is Subsequence](https://leetcode.com/problems/is-subsequence/) | Easy    | [C++](./algorithms/cpp/392_Iterative.cpp) | C++: Iterative approach. |C++: $O(n)$|C++: $O(1)$|
| 404  | [Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves/) | Easy    | [C++](./algorithms/cpp/404_Recursive.cpp) | C++: Use a recursive DFS approach, include a boolean to keep track of whether the last connection is a left or right connection. |C++: $O(n)$|C++: $O(h)$|
| 513  | [Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/) | Easy    | [C++](./algorithms/cpp/513_Recursive.cpp) | C++: Use a recursive DFS approach, to ensure the left-most value among the last row is encountered first. |C++: $O(n)$|C++: $O(h)$|
| 605  | [Can Place Flowers](https://leetcode.com/problems/can-place-flowers/) | Easy    | [C++](./algorithms/cpp/605_Iterative.cpp) | C++: Iterative approach, can also skip the next 1 or 2 elements if the current or the next element is occupied. |C++: $O(n)$|C++: $O(1)$|
| 637  | [Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/) | Easy    | [C++](./algorithms/cpp/637_Recursive.cpp) | C++: Recursive approach, use 2 vectors to store the sum at each level and the number of nodes at each level. |C++: $O(n)$|C++: $O(n)$|
| 643  | [Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/) | Easy    | [C++](./algorithms/cpp/643_Iterative.cpp) | C++: Iterative approach, just look for the maximum sum then do the averaging later, remember to do typecasting at the end to get the right result. |C++: $O(n)$|C++: $O(1)$|
| 649  | [Dota2 Senate](https://leetcode.com/problems/dota2-senate/) | Easy    | [C++](./algorithms/cpp/649_TwoQueues.cpp) | C++: Use the two-queue approach. Initialize two queues for the two factions with index as value. Compare the fronts of the queue (lower index survives), push the surviving senator to the end of the queue with its index + size of the input then pop both fronts of the queues till one queue is empty. The non-empty queue at the end wins.  |C++: $O(n)$|C++: $O(n)$|
| 700  | [Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/) | Easy    | [C++](./algorithms/cpp/700_Recursive.cpp) | C++: Recursive approach. |C++: $O(log(n))$|C++: $O(1)$|
| 704  | [Binary Search](https://leetcode.com/problems/binary-search/) | Easy    | [C++](./algorithms/cpp/704_TwoPointers.cpp) | C++: Two Pointers Approach. |C++: $O(log(n))$|C++: $O(1)$|
| 724  | [Find Pivot Index](https://leetcode.com/problems/find-pivot-index/) | Easy    | [C++](./algorithms/cpp/724_Iterative.cpp) | C++: Iterative approach. |C++: $O(n)$|C++: $O(1)$|
| 746  | [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/) | Easy    | [C++](./algorithms/cpp/746_Tabulation.cpp) | C++: Bottom-up DP approach. |C++: $O(n)$|C++: $O(1)$|
| 771 | [Jewels and Stones](https://leetcode.com/problems/jewels-and-stones/) | Easy    | [C++](./algorithms/cpp/771_Set.cpp) | C++: Use a set to lookup which stone is a jewel better. |C++: $O(n + m)$ with n being the number of characters and m being the number of characters in stones|C++: $O(n)$ with n being the number of characters in jewels|
| 804 | [Unique Morse Code Words](https://leetcode.com/problems/unique-morse-code-words/) | Easy    | [C++](./algorithms/cpp/804_ArraySet.cpp) | C++: Use an array to encode the characters then use a set to ensure the transformations are unique. The size of the set at the end is the number of unique transformations. |C++: $O(n * m)$|C++: $O(n * m)$|
| 872 | [Leaf-Similar Trees](https://leetcode.com/problems/leaf-similar-trees/) | Easy    | [C++](./algorithms/cpp/872_Recursive.cpp) | C++: Recursively get all the leaf values into 2 vectors, compare the vectors at the end. |C++: $O(n)$|C++: $O(n)$|
| 938  | [Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/) | Easy    | [C++](./algorithms/cpp/938_Recursive.cpp) | C++: Use a recursive DFS approach. |C++: $O(n)$|C++: $O(h)$|
| 1052  | [Grumpy Bookstore Owner](https://leetcode.com/problems/grumpy-bookstore-owner/) | Medium    | [C++](./algorithms/cpp/1052_SlidingWindow.cpp) | C++: Use sliding window, in the loop use 3 checks (1 for left, 1 for right and 1 for max update). |C++: $O(n)$|C++: $O(1)$|
| 1108  | [Defanging an IP Address](https://leetcode.com/problems/defanging-an-ip-address/) | Easy    | [C++](./algorithms/cpp/1108_StraightForward.cpp) | C++: Use a straightforward approach. |C++: $O(n)$|C++: $O(n)$|
| 1137  | [N-th Tribonacci Number](https://leetcode.com/problems/n-th-tribonacci-number/) | Easy    | [C++](./algorithms/cpp/1137_Iterative.cpp) | C++: Use an iterative approach (similar to DP but storing only 3 of the previously calculated values). |C++: $O(n)$|C++: $O(1)$|
| 1207 | [Unique Number of Occurrences](https://leetcode.com/problems/unique-number-of-occurrences/) | Easy    | [C++](./algorithms/cpp/1207_MapSet.cpp) | C++: Convert the array to a frequency map then iterate through the map and check for duplicate values using a set. |C++: $O(n)$|C++: $O(n)$|
| 1370| [Increasing Decreasing String](https://leetcode.com/problems/increasing-decreasing-string/) | Easy    | [C++](./algorithms/cpp/1370_Array.cpp) | C++: Build a frequency map with an array (we can achieve O(1) lookup because we only deal with the 26 English letters). While the result string is shorter than the input string, we alternately loop through the frequency map (incrementing then decrementing the index) and add in characters to the result string. |C++: $O(n)$|C++: $O(1)$|
| 1431  | [Kids With the Greatest Number of Candies](https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/) | Easy    | [C++](./algorithms/cpp/1431_Iterative.cpp) | C++: Find max then build boolean vector. |C++: $O(n)$|C++: $O(1)$|
| 1456  | [Maximum Number of Vowels in a Substring of Given Length](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/) | Medium    | [C++_Set](./algorithms/cpp/1456_SetSlidingWindow.cpp)<br><br>[C++_Conditionals](./algorithms/cpp/1456_ConditionalSlidingWindow.cpp) | C++_Set: Use 'find' or 'count' on a vowel set then use a sliding window to decrement or increment curVowels count for the subarray window.<br><br>C++_Conditionals: Use the same logic but check if the character is a vowel by conditions, it may be less readable and scalable but since the number of vowels are only 5, it often improves performance. |C++_Set: $O(n)$<br><br>C++_Conditionals: $O(n)$|C++_Set: $O(1)$<br><br>$O(1)$|
| 1470 | [Shuffle the Array](https://leetcode.com/problems/shuffle-the-array/) | Easy    | [C++](./algorithms/cpp/1470_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n)$|C++: $O(n)$|
| 1512  | [Number of Good Pairs](https://leetcode.com/problems/number-of-good-pairs/) | Easy    | [C++_MapSingleLoop](./algorithms/cpp/1512_MapSingleLoop.cpp)<br><br>[C++_MapTwoLoops](./algorithms/cpp/1512_MapTwoLoops.cpp) | C++_MapSingleLoop: Build a frequency map and increase the counter of good pairs at the same time (the number of good pairs is the sum of incrementing series of natural numbers to n - 1 with n being the number of occurrences of a number)<br><br>C++_MapTwoLoops: Use the same logic but calculate the the number of good pairs using the sum formula: $S_n = (n / 2)(n + 1)$ |C++_MapSingleLoop: $O(n)$<br><br>C++_MapTwoLoops: $O(n)$|C++_MapSingleLoop: $O(k)$ with k being the number of distinct elements<br><br>C++_MapTwoLoops:$O(k)$ with k being the number of distinct elements|
| 1614 | [Richest Customer Wealth](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/) | Easy    | [C++](./algorithms/cpp/1614_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n)$|C++: $O(1)$|
| 1672 | [Richest Customer Wealth](https://leetcode.com/problems/richest-customer-wealth/) | Easy    | [C++](./algorithms/cpp/1672_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n^2)$|C++: $O(1)$|
| 1684 | [Count of Number of Consistent Strings](https://leetcode.com/problems/count-the-number-of-consistent-strings/) | Easy    | [C++](./algorithms/cpp/1684_Array.cpp) | C++: Build a boolean array to keep track of which of the 26 English letters are allowed. Loop through the words and if there exists a disallowed letter, decrement the counter. |C++: $O(n^2)$|C++: $O(1)$|
| 1732  | [Find the Highest Altitude](https://leetcode.com/problems/find-the-highest-altitude/) | Easy    | [C++](./algorithms/cpp/1732_Iterative.cpp) | C++: Iterative approach. |C++: $O(n)$|C++: $O(1)$|
| 1742  | [Maximum Number of Balls in a Box](https://leetcode.com/problems/maximum-number-of-balls-in-a-box/) | Easy    | [C++](./algorithms/cpp/1742_Array.cpp) | C++: Our first intuition is to use a hash but it is not necessary, we can just use an array of 46 integers to keep track of the frequency (because the highLimit is constrained to be not larger than 10^5). |C++: $O(n)$|C++: $O(1)$|
| 1748  | [Sum of Unique Elements](https://leetcode.com/problems/sum-of-unique-elements/) | Easy    | [C++](./algorithms/cpp/1748_Map.cpp) | C++: Build a frequency map then sum the numbers that appear once. |C++: $O(n)$|C++: $O(n)$|
| 1768  | [Merge Strings Alternately](https://leetcode.com/problems/merge-strings-alternately/) | Easy    | [C++](./algorithms/cpp/1768_OnePointer.cpp) | C++: Use only one pointer to keep track of the indices. |C++: $O(n)$|C++: $O(1)$|
| 1832 | [Check if the Sentence Is Pangram](https://leetcode.com/problems/check-if-the-sentence-is-pangram/) | Easy    | [C++](./algorithms/cpp/1832_Array.cpp) | C++: Use a boolean array corresponding to the 26 English letters, if the currentElement has not been seen, increase the seen number counter and turn the hasSeen boolean value to the according letter to true. If the counter is equal to 26, return true. |C++: $O(n)$|C++: $O(1)$|
| 1920 | [Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/) | Easy    | [C++](./algorithms/cpp/1920_Iterative.cpp) | C++: Iterative approach. |C++: $O(n)$|C++: $O(n)$|
| 1929  | [Concatenation of Array](https://leetcode.com/problems/concatenation-of-arry/) | Easy    | [C++](./algorithms/cpp/1929_Iterative.cpp) | C++: Iterative approach with the modulo operator. |C++: $O(n)$|C++: $O(n)$|
| 2037  | [Minimum Number of Moves to Seat Everyone](https://leetcode.com/problems/mininum-number-of-moves-to-seat-everyone/) | Easy    | [C++](./algorithms/cpp/2037_Sorting.cpp) | C++: Sort the arrays, then calculate the difference between the paired elements. |C++: $O(nlog(n))$|C++: $O(log(n))$|
| 2215 | [Find the Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/) | Easy    | [C++](./algorithms/cpp/2215_Set.cpp) | C++: Use sets to avoid duplicates and constant lookup time. |C++: $O(n)$|C++: $O(n)$|
| 2325 | [Decode the Message](https://leetcode.com/problems/decode-the-message/) | Easy    | [C++_Map](./algorithms/cpp/2325_Map.cpp) | C++_Map: Build a substitution table with a map then decode the message string. |C++_Map: $O(m)$ with m being the size of message |C++_Map: $O(1)$ because at most we'll store 26 elements in a map. |
| 2351 | [First Letter to Appear Twice](https://leetcode.com/problems/first-letter-to-appear-twice/) | Easy    | [C++_Set](./algorithms/cpp/2351_Set.cpp) | C++: Use a set to keep track of which letter has been seen. |C++: $O(n)$ |C++: $O(1)$ because at most we'll store 26 elements in the set. |
| 2384 | [Largest Palindromic Number](https://leetcode.com/problems/largest-palindromic-number/) | Medium    | [C++_Array](./algorithms/cpp/2384_Array.cpp) | C++: Build a frequency map with an array, build a decreasing left string (remember to skip leading zeroes), build a middle string if there is a left-over digit, build a right string (reversed left string) and append all three small strings to return. |C++: $O(n)$ |C++: $O(1)$ because at most we'll store 26 elements in the set. |
| 2413 | [Smallest Even Multiple](https://leetcode.com/problems/smallest-even-multiple/) | Easy    | [C++](./algorithms/cpp/2413_StraightForward.cpp) | C++: Straightforward approach. |C++: $O(1)$ |C++: $O(1)$ |
| 2469 | [Convert the Temperature](https://leetcode.com/problems/convert-the-temperature/) | Easy    | [C++](./algorithms/cpp/2469_StraightForward.cpp) | C++: Straightforward approach. |C++: $O(1)$ |C++: $O(1)$ |
| 2716 | [Minimize String Length](https://leetcode.com/problems/first-letter-to-appear-twice/) | Easy    | [C++](./algorithms/cpp/2716_Array.cpp) | C++: This problem can be restated as counting the number of distinct elements. We can use a boolean arrays of 26 elements to keep track of which character has been seen. Return the number of 'true' in the array. |C++: $O(n)$ |C++: $O(1)$ |
| 2769 | [Find the Maximum Achievable Number](https://leetcode.com/problems/find-the-maximum-achievable-number/) | Easy    | [C++](./algorithms/cpp/2769_StraightForward.cpp) | C++: One liner. |C++: $O(1)$ |C++: $O(1)$ |
| 2798 | [Number of Employees Who Met the Target](https://leetcode.com/problems/number-of-employees-who-met-the-target/) | Easy    | [C++](./algorithms/cpp/2798_StraightForward.cpp) | C++: Straightforward approach. |C++: $O(1)$ |C++: $O(1)$ |
| 2842| [Count Pairs Whose Sum is Less than Target](https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/) | Easy    | [C++](./algorithms/cpp/2842_Iterative.cpp) | C++: Iterative approach. |C++: $O(n^2)$ |C++: $O(1)$ |
| 2903| [Find Indices With Index and Value Difference I](https://leetcode.com/problems/find-indices-with-index-and-value-difference-i/) | Easy    | [C++](./algorithms/cpp/2903_Iterative.cpp) | C++: Iterative approach. |C++: $O(n^2)$ |C++: $O(1)$ |
| 2942 | [Find Words Containing Character](https://leetcode.com/problems/find-words-containing-character/) | Easy    | [C++](./algorithms/cpp/2942_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n * m)$ with n being the number of words and m being the number of characters a word has. |C++: $O(n)$|
| 3110 | [Score of a String](https://leetcode.com/problems/score-of-a-string/) | Easy    | [C++](./algorithms/cpp/3110_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n)$|C++: $O(1)$|
| 3121 | [Count the Number of Special Characters II](https://leetcode.com/problems/count-the-number-of-special-characters-ii/) | Medium    | [C++](./algorithms/cpp/3121_Array.cpp) | C++: Use two arrays to keep track of whether the character is seen. Iterate through the input word, if the current character is lowercase then change the lowercase values to the opposite of the uppercase values, if the current character is uppercase then switch the bool value to true. |C++: $O(n)$|C++: $O(1)$|
| 3146 | [Permutation Difference between Two Strings](https://leetcode.com/problems/permutation-difference-between-two-strings/) | Easy    | [C++](./algorithms/cpp/3146_Set.cpp) | C++: Use a single set to store the index of characters in string s then directly calculate the difference while looping through string t. |C++: $O(n)$|C++: $O(n)$|
| 3162 | [Find the Number of Good Pairs I](https://leetcode.com/problems/find-the-number-of-good-pairs-i/) | Easy    | [C++](./algorithms/cpp/3162_Iterative.cpp) | C++: Use an iterative approach. |C++: $O(n^2)$|C++: $O(1)$|
| 3190 | [Find Minimum Operations to Make All Elements Divisible by Three](https://leetcode.com/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/) | Easy    | [C++](./algorithms/cpp/3190_Iterative.cpp) | C++: The problem is exactly the same as finding the number of elements that are not divisible by three (because we can make non-divisible by three into divisible by three in one operation).|C++: $O(n)$|C++: $O(1)$|